<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Coloring - Math Visual Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .glow-text { text-shadow: 0 0 20px rgba(168, 85, 247, 0.5); }
        input[type="range"] {
            -webkit-appearance: none;
            background: #1f2937;
            border-radius: 4px;
            height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #a855f7;
            border-radius: 50%;
            cursor: pointer;
        }
        .math-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(34, 211, 238, 0.05));
            border: 1px solid rgba(168, 85, 247, 0.3);
        }
        #canvas { cursor: crosshair; }
        .guide-link {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: #c4b5fd;
            text-decoration: none;
            font-size: 0.8rem;
            transition: all 0.3s;
            margin-top: 16px;
        }
        .guide-link:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: #a855f7;
        }
        .guide-icon {
            width: 18px;
            height: 18px;
            background: #a855f7;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }
    </style>
</head>
<body class="bg-black text-gray-100 min-h-screen">
    <header class="border-b border-gray-900 bg-black/80 backdrop-blur-sm sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 py-3">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-4">
                    <a href="index.html" class="text-gray-500 hover:text-violet-400 transition flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                        </svg>
                        Volver
                    </a>
                    <div class="h-4 w-px bg-gray-800"></div>
                    <h1 class="text-lg font-light">
                        <span class="text-violet-400 font-medium">Domain Coloring</span>
                    </h1>
                </div>
                <div class="flex items-center gap-4 text-sm mono">
                    <span class="text-gray-500">z = <span id="z-display" class="text-cyan-400">0 + 0i</span></span>
                    <span class="text-gray-500">f(z) = <span id="fz-display" class="text-violet-400">0 + 0i</span></span>
                </div>
            </div>
        </div>
    </header>

    <main class="flex h-[calc(100vh-57px)]">
        <div class="flex-1 flex items-center justify-center bg-gray-950">
            <canvas id="canvas" width="700" height="700"></canvas>
        </div>

        <aside class="w-80 border-l border-gray-900 bg-gray-950 p-6 overflow-y-auto">
            <h2 class="text-lg font-medium mb-6 text-violet-400 glow-text">Controles</h2>

            <div class="mb-6">
                <label class="block text-sm text-gray-400 mb-2">Función f(z)</label>
                <select id="function-select" class="w-full bg-gray-900 border border-gray-800 rounded-lg px-3 py-2 text-sm focus:border-violet-500 focus:outline-none">
                    <option value="z">z (identidad)</option>
                    <option value="z2" selected>z²</option>
                    <option value="z3">z³</option>
                    <option value="z4">z⁴</option>
                    <option value="1/z">1/z</option>
                    <option value="sqrt">√z</option>
                    <option value="exp">eᶻ</option>
                    <option value="sin">sin(z)</option>
                    <option value="cos">cos(z)</option>
                    <option value="tan">tan(z)</option>
                    <option value="log">log(z)</option>
                    <option value="sinh">sinh(z)</option>
                    <option value="cosh">cosh(z)</option>
                    <option value="z2-1">(z²-1)</option>
                    <option value="z3-1">(z³-1)</option>
                    <option value="z+1/z">z + 1/z</option>
                    <option value="gamma">Γ(z) (aprox)</option>
                    <option value="zeta">ζ(z) (aprox)</option>
                </select>
            </div>

            <div class="mb-6">
                <label class="block text-sm text-gray-400 mb-2">
                    Rango: <span id="range-value" class="text-violet-400 mono">±3</span>
                </label>
                <input type="range" id="range-slider" min="0.5" max="10" step="0.5" value="3" class="w-full">
            </div>

            <div class="mb-6">
                <label class="block text-sm text-gray-400 mb-2">Visualización</label>
                <div class="space-y-2">
                    <label class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="show-modulus" checked class="w-4 h-4 rounded bg-gray-900 border-gray-700 text-violet-500">
                        <span class="text-sm text-gray-400">Mostrar módulo (brillo)</span>
                    </label>
                    <label class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="show-grid" class="w-4 h-4 rounded bg-gray-900 border-gray-700 text-violet-500">
                        <span class="text-sm text-gray-400">Líneas de nivel</span>
                    </label>
                    <label class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="enhanced-phase" class="w-4 h-4 rounded bg-gray-900 border-gray-700 text-violet-500">
                        <span class="text-sm text-gray-400">Fase mejorada</span>
                    </label>
                </div>
            </div>

            <div class="mb-6">
                <label class="block text-sm text-gray-400 mb-2">Presets Interesantes</label>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setPreset('z3-1', 2)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Raíces de z³-1</button>
                    <button onclick="setPreset('1/z', 2)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Polo en origen</button>
                    <button onclick="setPreset('exp', 5)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Exponencial</button>
                    <button onclick="setPreset('sin', 5)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Seno complejo</button>
                    <button onclick="setPreset('tan', 5)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Tangente</button>
                    <button onclick="setPreset('gamma', 5)" class="px-3 py-2 bg-gray-900 hover:bg-gray-800 rounded-lg text-xs transition">Función Gamma</button>
                </div>
            </div>

            <div class="mb-6 p-4 bg-gray-900 rounded-lg">
                <h3 class="text-sm font-medium text-gray-300 mb-2">Leyenda de Colores</h3>
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-full h-4 rounded" style="background: linear-gradient(to right, hsl(0,100%,50%), hsl(60,100%,50%), hsl(120,100%,50%), hsl(180,100%,50%), hsl(240,100%,50%), hsl(300,100%,50%), hsl(360,100%,50%))"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-500">
                    <span>0°</span>
                    <span>90°</span>
                    <span>180°</span>
                    <span>270°</span>
                    <span>360°</span>
                </div>
                <p class="text-xs text-gray-500 mt-2">Color = argumento (fase), Brillo = módulo</p>
            </div>

            <div class="math-box rounded-xl p-4">
                <h3 class="text-sm font-medium text-violet-400 mb-3">La Matemática</h3>
                <div class="mono text-sm text-center mb-3 text-cyan-400">
                    f(z) = f(x + iy) = u(x,y) + iv(x,y)
                </div>
                <p class="text-xs text-gray-400 leading-relaxed">
                    El <strong>domain coloring</strong> visualiza funciones complejas usando color para representar el argumento (ángulo) y brillo para el módulo (magnitud).
                </p>
                <div class="mt-3 pt-3 border-t border-gray-800">
                    <p class="text-xs text-gray-500">
                        Los <span class="text-red-400">ceros</span> aparecen donde todos los colores convergen en un punto oscuro. Los <span class="text-yellow-400">polos</span> son puntos brillantes donde todos los colores convergen.
                    </p>
                </div>
            </div>

            <!-- STL Export -->
            <div class="mt-6">
                <button id="stl-toggle" class="w-full py-2 px-4 bg-emerald-500/20 hover:bg-emerald-500/30 text-emerald-400 rounded-lg text-sm transition flex items-center justify-center gap-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                    Exportar STL
                </button>
                <div id="stl-panel" class="hidden mt-3 space-y-3">
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Resolución: <span id="res-val" class="text-emerald-400 mono">200</span></label>
                        <input type="range" id="stl-res" min="50" max="400" step="50" value="200" class="w-full">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Altura max: <span id="height-val" class="text-emerald-400 mono">15</span> mm</label>
                        <input type="range" id="stl-height" min="5" max="30" step="1" value="15" class="w-full">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Tamaño: <span id="size-val" class="text-emerald-400 mono">100</span> mm</label>
                        <input type="range" id="stl-size" min="60" max="150" step="10" value="100" class="w-full">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Base: <span id="base-val" class="text-emerald-400 mono">2</span> mm</label>
                        <input type="range" id="stl-base" min="1" max="5" step="0.5" value="2" class="w-full">
                    </div>
                    <button id="stl-export" class="w-full py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition">
                        Descargar STL
                    </button>
                    <div id="stl-status" class="text-xs text-gray-500 mono text-center"></div>
                </div>
            </div>

            <a href="guides/domain-coloring.html" class="guide-link">
                <span class="guide-icon">?</span>
                Guía completa: funciones complejas, polos y ceros, transformaciones conformes
            </a>
        </aside>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(canvas.width, canvas.height);

        let currentFunction = 'z2';
        let range = 3;
        let showModulus = true;
        let showGrid = false;
        let enhancedPhase = false;

        // Complex number operations
        function cAdd(a, b) { return { re: a.re + b.re, im: a.im + b.im }; }
        function cSub(a, b) { return { re: a.re - b.re, im: a.im - b.im }; }
        function cMul(a, b) { return { re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re }; }
        function cDiv(a, b) {
            const d = b.re * b.re + b.im * b.im;
            if (d === 0) return { re: Infinity, im: Infinity };
            return { re: (a.re * b.re + a.im * b.im) / d, im: (a.im * b.re - a.re * b.im) / d };
        }
        function cAbs(z) { return Math.sqrt(z.re * z.re + z.im * z.im); }
        function cArg(z) { return Math.atan2(z.im, z.re); }
        function cExp(z) {
            const r = Math.exp(z.re);
            return { re: r * Math.cos(z.im), im: r * Math.sin(z.im) };
        }
        function cLog(z) {
            return { re: Math.log(cAbs(z)), im: cArg(z) };
        }
        function cSin(z) {
            return { re: Math.sin(z.re) * Math.cosh(z.im), im: Math.cos(z.re) * Math.sinh(z.im) };
        }
        function cCos(z) {
            return { re: Math.cos(z.re) * Math.cosh(z.im), im: -Math.sin(z.re) * Math.sinh(z.im) };
        }
        function cTan(z) { return cDiv(cSin(z), cCos(z)); }
        function cSinh(z) {
            return { re: Math.sinh(z.re) * Math.cos(z.im), im: Math.cosh(z.re) * Math.sin(z.im) };
        }
        function cCosh(z) {
            return { re: Math.cosh(z.re) * Math.cos(z.im), im: Math.sinh(z.re) * Math.sin(z.im) };
        }
        function cPow(z, n) {
            const r = Math.pow(cAbs(z), n);
            const theta = cArg(z) * n;
            return { re: r * Math.cos(theta), im: r * Math.sin(theta) };
        }
        function cSqrt(z) { return cPow(z, 0.5); }

        // Gamma function approximation (Stirling)
        function cGamma(z) {
            // Lanczos approximation
            const g = 7;
            const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                771.32342877765313, -176.61502916214059, 12.507343278686905,
                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];

            if (z.re < 0.5) {
                // Reflection formula
                const sinPiZ = cSin(cMul({ re: Math.PI, im: 0 }, z));
                const reflected = cGamma(cSub({ re: 1, im: 0 }, z));
                return cDiv({ re: Math.PI, im: 0 }, cMul(sinPiZ, reflected));
            }

            z = cSub(z, { re: 1, im: 0 });
            let x = { re: c[0], im: 0 };
            for (let i = 1; i < g + 2; i++) {
                x = cAdd(x, cDiv({ re: c[i], im: 0 }, cAdd(z, { re: i, im: 0 })));
            }
            const t = cAdd(z, { re: g + 0.5, im: 0 });
            const sqrt2pi = Math.sqrt(2 * Math.PI);
            return cMul(cMul({ re: sqrt2pi, im: 0 }, cPow(t, cAdd(z, { re: 0.5, im: 0 }).re)), cMul(cExp(cMul({ re: -1, im: 0 }, t)), x));
        }

        // Riemann Zeta approximation
        function cZeta(z) {
            if (z.re > 1 || (z.re === 1 && z.im === 0)) {
                let sum = { re: 0, im: 0 };
                for (let n = 1; n < 50; n++) {
                    const term = cDiv({ re: 1, im: 0 }, cPow({ re: n, im: 0 }, z.re));
                    sum = cAdd(sum, { re: term.re * Math.cos(-z.im * Math.log(n)), im: term.re * Math.sin(-z.im * Math.log(n)) });
                }
                return sum;
            }
            // Use functional equation for re < 1
            const twoPI = { re: 2 * Math.PI, im: 0 };
            const factor1 = cPow(twoPI, z);
            const factor2 = cSin(cMul({ re: Math.PI / 2, im: 0 }, z));
            const factor3 = cGamma(cSub({ re: 1, im: 0 }, z));
            const factor4 = cZeta(cSub({ re: 1, im: 0 }, z));
            return cMul(cMul(cMul(factor1, factor2), factor3), factor4);
        }

        // Evaluate selected function
        function evaluate(z) {
            switch (currentFunction) {
                case 'z': return z;
                case 'z2': return cMul(z, z);
                case 'z3': return cMul(cMul(z, z), z);
                case 'z4': return cPow(z, 4);
                case '1/z': return cDiv({ re: 1, im: 0 }, z);
                case 'sqrt': return cSqrt(z);
                case 'exp': return cExp(z);
                case 'sin': return cSin(z);
                case 'cos': return cCos(z);
                case 'tan': return cTan(z);
                case 'log': return cLog(z);
                case 'sinh': return cSinh(z);
                case 'cosh': return cCosh(z);
                case 'z2-1': return cSub(cMul(z, z), { re: 1, im: 0 });
                case 'z3-1': return cSub(cMul(cMul(z, z), z), { re: 1, im: 0 });
                case 'z+1/z': return cAdd(z, cDiv({ re: 1, im: 0 }, z));
                case 'gamma': return cGamma(z);
                case 'zeta': return cZeta(z);
                default: return z;
            }
        }

        // HSL to RGB conversion
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Convert complex number to color
        function complexToColor(w) {
            let arg = cArg(w);
            if (arg < 0) arg += 2 * Math.PI;
            const hue = arg / (2 * Math.PI);

            let mod = cAbs(w);
            let lightness = 0.5;

            if (showModulus) {
                // Use log scale for better visualization
                const logMod = Math.log(mod + 1);
                lightness = 0.5 - 0.4 * Math.atan(logMod - 1) / Math.PI;
                lightness = Math.max(0.1, Math.min(0.9, lightness));
            }

            let saturation = 0.9;

            if (showGrid) {
                // Add contour lines
                const logMod2 = Math.log2(mod + 0.001);
                const argLines = arg * 6 / Math.PI;
                const modFrac = logMod2 - Math.floor(logMod2);
                const argFrac = argLines - Math.floor(argLines);

                if (modFrac < 0.05 || modFrac > 0.95 || argFrac < 0.05 || argFrac > 0.95) {
                    lightness *= 0.7;
                }
            }

            if (enhancedPhase) {
                // Make phase more visible
                const phaseLines = arg * 12 / Math.PI;
                const phaseFrac = phaseLines - Math.floor(phaseLines);
                if (phaseFrac > 0.9) {
                    lightness *= 0.8;
                }
            }

            return hslToRgb(hue, saturation, lightness);
        }

        function render() {
            const w = canvas.width;
            const h = canvas.height;

            for (let py = 0; py < h; py++) {
                for (let px = 0; px < w; px++) {
                    const x = (px / w - 0.5) * 2 * range;
                    const y = (0.5 - py / h) * 2 * range;

                    const z = { re: x, im: y };
                    const fz = evaluate(z);

                    const [r, g, b] = complexToColor(fz);

                    const idx = (py * w + px) * 4;
                    imageData.data[idx] = r;
                    imageData.data[idx + 1] = g;
                    imageData.data[idx + 2] = b;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw axes
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(w/2, 0);
            ctx.lineTo(w/2, h);
            ctx.moveTo(0, h/2);
            ctx.lineTo(w, h/2);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px JetBrains Mono';
            ctx.fillText(`${range}`, w - 25, h/2 - 5);
            ctx.fillText(`-${range}`, 5, h/2 - 5);
            ctx.fillText(`${range}i`, w/2 + 5, 15);
            ctx.fillText(`-${range}i`, w/2 + 5, h - 5);
        }

        function setPreset(func, newRange) {
            currentFunction = func;
            range = newRange;
            document.getElementById('function-select').value = func;
            document.getElementById('range-slider').value = newRange;
            document.getElementById('range-value').textContent = `±${newRange}`;
            render();
        }

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            const x = (px / canvas.width - 0.5) * 2 * range;
            const y = (0.5 - py / canvas.height) * 2 * range;

            const z = { re: x, im: y };
            const fz = evaluate(z);

            document.getElementById('z-display').textContent =
                `${x.toFixed(2)} ${y >= 0 ? '+' : '-'} ${Math.abs(y).toFixed(2)}i`;
            document.getElementById('fz-display').textContent =
                `${fz.re.toFixed(2)} ${fz.im >= 0 ? '+' : '-'} ${Math.abs(fz.im).toFixed(2)}i`;
        });

        // Event listeners
        document.getElementById('function-select').addEventListener('change', (e) => {
            currentFunction = e.target.value;
            render();
        });

        document.getElementById('range-slider').addEventListener('input', (e) => {
            range = parseFloat(e.target.value);
            document.getElementById('range-value').textContent = `±${range}`;
            render();
        });

        document.getElementById('show-modulus').addEventListener('change', (e) => {
            showModulus = e.target.checked;
            render();
        });

        document.getElementById('show-grid').addEventListener('change', (e) => {
            showGrid = e.target.checked;
            render();
        });

        document.getElementById('enhanced-phase').addEventListener('change', (e) => {
            enhancedPhase = e.target.checked;
            render();
        });

        // === STL Export ===
        function buildSTL(tris) {
            const buf = new ArrayBuffer(84 + tris.length * 50);
            const v = new DataView(buf);
            const hdr = 'Binary STL - EigenLab';
            for (let i = 0; i < hdr.length; i++) v.setUint8(i, hdr.charCodeAt(i));
            v.setUint32(80, tris.length, true);
            let o = 84;
            for (const [a, b, c] of tris) {
                const u0=b[0]-a[0],u1=b[1]-a[1],u2=b[2]-a[2];
                const w0=c[0]-a[0],w1=c[1]-a[1],w2=c[2]-a[2];
                let nx=u1*w2-u2*w1,ny=u2*w0-u0*w2,nz=u0*w1-u1*w0;
                const l=Math.sqrt(nx*nx+ny*ny+nz*nz);
                if(l>0){nx/=l;ny/=l;nz/=l;}
                v.setFloat32(o,nx,true);o+=4;v.setFloat32(o,ny,true);o+=4;v.setFloat32(o,nz,true);o+=4;
                for(const p of[a,b,c]){v.setFloat32(o,p[0],true);o+=4;v.setFloat32(o,p[1],true);o+=4;v.setFloat32(o,p[2],true);o+=4;}
                v.setUint16(o,0,true);o+=2;
            }
            return new Blob([buf],{type:'application/octet-stream'});
        }

        function exportDomainSTL() {
            const res = parseInt(document.getElementById('stl-res').value);
            const maxH = parseFloat(document.getElementById('stl-height').value);
            const totalSize = parseFloat(document.getElementById('stl-size').value);
            const baseH = parseFloat(document.getElementById('stl-base').value);
            const stEl = document.getElementById('stl-status');
            stEl.textContent = 'Calculando heightmap...';

            setTimeout(() => {
                // Evaluate |f(z)| on a grid
                const hmap = [];
                let hMin = Infinity, hMax = -Infinity;
                for (let iy = 0; iy <= res; iy++) {
                    hmap[iy] = [];
                    for (let ix = 0; ix <= res; ix++) {
                        const x = (ix / res - 0.5) * 2 * range;
                        const y = (0.5 - iy / res) * 2 * range;
                        const fz = evaluate({ re: x, im: y });
                        let h = cAbs(fz);
                        if (!isFinite(h)) h = 0;
                        // Use log scale to tame poles
                        h = Math.log(1 + h);
                        hmap[iy][ix] = h;
                        if (h < hMin) hMin = h;
                        if (h > hMax) hMax = h;
                    }
                }

                const hRange = hMax - hMin || 1;
                const cellW = totalSize / res;
                const tris = [];

                stEl.textContent = `Generando mesh (${res}x${res})...`;
                setTimeout(() => {
                    // Top surface
                    for (let iy = 0; iy < res; iy++) {
                        for (let ix = 0; ix < res; ix++) {
                            const x0=ix*cellW, x1=(ix+1)*cellW, y0=iy*cellW, y1=(iy+1)*cellW;
                            const z00=baseH+((hmap[iy][ix]-hMin)/hRange)*maxH;
                            const z10=baseH+((hmap[iy][ix+1]-hMin)/hRange)*maxH;
                            const z01=baseH+((hmap[iy+1][ix]-hMin)/hRange)*maxH;
                            const z11=baseH+((hmap[iy+1][ix+1]-hMin)/hRange)*maxH;
                            tris.push([[x0,y0,z00],[x1,y0,z10],[x1,y1,z11]]);
                            tris.push([[x0,y0,z00],[x1,y1,z11],[x0,y1,z01]]);
                        }
                    }
                    // Bottom face
                    tris.push([[0,0,0],[totalSize,0,0],[totalSize,totalSize,0]]);
                    tris.push([[0,0,0],[totalSize,totalSize,0],[0,totalSize,0]]);
                    // 4 side walls
                    for (let i = 0; i < res; i++) {
                        const a=i*cellW, b=(i+1)*cellW;
                        // Front (iy=0)
                        const zf0=baseH+((hmap[0][i]-hMin)/hRange)*maxH;
                        const zf1=baseH+((hmap[0][i+1]-hMin)/hRange)*maxH;
                        tris.push([[a,0,0],[b,0,0],[b,0,zf1]]);
                        tris.push([[a,0,0],[b,0,zf1],[a,0,zf0]]);
                        // Back (iy=res)
                        const zb0=baseH+((hmap[res][i]-hMin)/hRange)*maxH;
                        const zb1=baseH+((hmap[res][i+1]-hMin)/hRange)*maxH;
                        tris.push([[b,totalSize,0],[a,totalSize,0],[a,totalSize,zb0]]);
                        tris.push([[b,totalSize,0],[a,totalSize,zb0],[b,totalSize,zb1]]);
                        // Left (ix=0)
                        const zl0=baseH+((hmap[i][0]-hMin)/hRange)*maxH;
                        const zl1=baseH+((hmap[i+1][0]-hMin)/hRange)*maxH;
                        tris.push([[0,b,0],[0,a,0],[0,a,zl0]]);
                        tris.push([[0,b,0],[0,a,zl0],[0,b,zl1]]);
                        // Right (ix=res)
                        const zr0=baseH+((hmap[i][res]-hMin)/hRange)*maxH;
                        const zr1=baseH+((hmap[i+1][res]-hMin)/hRange)*maxH;
                        tris.push([[totalSize,a,0],[totalSize,b,0],[totalSize,b,zr1]]);
                        tris.push([[totalSize,a,0],[totalSize,b,zr1],[totalSize,a,zr0]]);
                    }

                    const blob = buildSTL(tris);
                    const name = `domain-${currentFunction}-r${range}.stl`;
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = name;
                    a.click();
                    stEl.textContent = `${name} (${(blob.size/1024).toFixed(0)} KB, ${tris.length} tri)`;
                }, 10);
            }, 10);
        }

        document.getElementById('stl-toggle').addEventListener('click',()=>{
            document.getElementById('stl-panel').classList.toggle('hidden');
        });
        document.getElementById('stl-res').addEventListener('input',e=>{
            document.getElementById('res-val').textContent=e.target.value;
        });
        document.getElementById('stl-height').addEventListener('input',e=>{
            document.getElementById('height-val').textContent=e.target.value;
        });
        document.getElementById('stl-size').addEventListener('input',e=>{
            document.getElementById('size-val').textContent=e.target.value;
        });
        document.getElementById('stl-base').addEventListener('input',e=>{
            document.getElementById('base-val').textContent=e.target.value;
        });
        document.getElementById('stl-export').addEventListener('click',exportDomainSTL);

        // Initial render
        render();
    </script>
</body>
</html>
