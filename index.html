<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Visual Lab - Visualizaciones Matemáticas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .card {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px rgba(168, 85, 247, 0.15);
        }
        .card-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }
        .card:hover .card-border {
            opacity: 1;
        }
        .card-border {
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            padding: 2px;
            background: linear-gradient(135deg, #a855f7, #22d3ee, #a3e635);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .preview-canvas {
            border-radius: 0.5rem;
        }
        .equation {
            font-family: 'JetBrains Mono', monospace;
            font-style: normal;
        }
        .category-tag {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 9999px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.5);
        }
        .math-symbol {
            font-family: 'Times New Roman', serif;
            font-size: 1.5rem;
        }
        .stl-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 0.6rem;
            padding: 2px 7px;
            border-radius: 9999px;
            background: rgba(16, 185, 129, 0.15);
            color: #34d399;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'JetBrains Mono', monospace;
            vertical-align: middle;
            margin-left: 6px;
        }
    </style>
</head>
<body class="bg-black text-gray-100 min-h-screen">
    <!-- Header -->
    <header class="border-b border-gray-900 bg-black/80 backdrop-blur-sm sticky top-0 z-50">
        <div class="max-w-6xl mx-auto px-6 py-4">
            <div class="flex justify-between items-center">
                <div>
                    <nav class="text-xs text-gray-600 mb-1">
                        <a href="../../_portal/index.html" class="hover:text-violet-400 transition">EigenLab</a>
                        <span class="mx-1">/</span>
                        <span class="text-gray-500">Math Visual Lab</span>
                    </nav>
                    <h1 class="text-2xl font-light">
                        <span class="text-violet-400 font-medium glow-text">Math</span> Visual Lab
                    </h1>
                    <p class="text-gray-600 text-sm mono">La belleza de la abstracción</p>
                </div>
                <div class="flex items-center gap-4">
                    <span class="math-symbol text-cyan-400">∑</span>
                    <span class="math-symbol text-pink-400">∫</span>
                    <span class="math-symbol text-lime-400">π</span>
                    <span class="math-symbol text-violet-400">∞</span>
                    <a href="https://github.com/cjlkaiser-cpu" target="_blank" class="text-gray-500 hover:text-white transition ml-2">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
                    </a>
                </div>
            </div>
        </div>
    </header>

    <main class="max-w-6xl mx-auto px-6 py-12">
        <!-- Hero -->
        <section class="text-center mb-16">
            <h2 class="text-4xl font-light mb-4">
                Matemáticas <span class="text-violet-400 font-medium glow-text">visuales</span>
            </h2>
            <p class="text-gray-500 max-w-2xl mx-auto">
                30+ experiencias interactivas y 3 laboratorios modulares donde los algoritmos cobran vida.
                Fractales, caos, cálculo, topología, poliedros y geometría computacional.
            </p>
        </section>

        <!-- Laboratorios Destacados -->
        <section class="mb-16">
            <h3 class="text-xl font-light mb-2 text-center">
                <span class="text-cyan-400 font-medium">Laboratorios</span> Interactivos
            </h3>
            <p class="text-gray-600 text-sm text-center mb-8">Entornos modulares con tutoriales, cursos y herramientas avanzadas</p>

            <div class="grid md:grid-cols-3 gap-6">

                <!-- Platonic Lab -->
                <a href="platonic-lab/index.html" class="card-link">
                    <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                        <div class="card-border"></div>
                        <div class="p-5">
                            <canvas id="preview-platonic" class="preview-canvas w-full h-32 bg-black rounded-lg mb-4"></canvas>
                            <span class="category-tag bg-yellow-500/10 text-yellow-400">Geometría 3D</span>
                            <h3 class="text-lg font-medium mb-1 mt-2">Platonic Lab</h3>
                            <p class="text-gray-500 text-sm mb-3">Los 5 sólidos platónicos, operadores de Conway, poliedros arquimedianos, politopos 4D, diagramas de Schlegel y sintetizador de Kepler.</p>
                            <div class="flex flex-wrap gap-1 mb-3">
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Conway</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">4D</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Curso</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Tutorial</span>
                            </div>
                            <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                                Explorar Poliedros →
                            </span>
                        </div>
                    </div>
                </a>

                <!-- Chaos Lab -->
                <a href="chaos-lab/index.html" class="card-link">
                    <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                        <div class="card-border"></div>
                        <div class="p-5">
                            <canvas id="preview-chaos" class="preview-canvas w-full h-32 bg-black rounded-lg mb-4"></canvas>
                            <span class="category-tag bg-violet-500/20 text-violet-400">Sistemas Dinámicos</span>
                            <h3 class="text-lg font-medium mb-1 mt-2">Chaos Lab</h3>
                            <p class="text-gray-500 text-sm mb-3">Atractores extraños, exponentes de Lyapunov, diagramas de bifurcación, análisis de sensibilidad y sistemas caóticos interactivos.</p>
                            <div class="flex flex-wrap gap-1 mb-3">
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Lorenz</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Lyapunov</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Showcase</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Tutorial</span>
                            </div>
                            <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                                Explorar Caos →
                            </span>
                        </div>
                    </div>
                </a>

                <!-- Polytope XD -->
                <a href="polytope-xd/index.html" class="card-link">
                    <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                        <div class="card-border"></div>
                        <div class="p-5">
                            <canvas id="preview-polytope" class="preview-canvas w-full h-32 bg-black rounded-lg mb-4"></canvas>
                            <span class="category-tag bg-cyan-500/10 text-cyan-400">Dimensiones Superiores</span>
                            <h3 class="text-lg font-medium mb-1 mt-2">Polytope XD</h3>
                            <p class="text-gray-500 text-sm mb-3">Politopos en dimensiones arbitrarias: teseracto, 24-cell, 120-cell, 600-cell. Secciones, proyecciones y rotaciones 4D.</p>
                            <div class="flex flex-wrap gap-1 mb-3">
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">4D/5D</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Slicer</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-800 rounded-full text-gray-400">Tutorial</span>
                            </div>
                            <span class="block w-full text-center py-2 bg-cyan-500/10 text-cyan-400 rounded-lg hover:bg-cyan-500/20 transition text-sm font-medium">
                                Explorar Dimensiones →
                            </span>
                        </div>
                    </div>
                </a>

            </div>
        </section>

        <!-- Simulaciones -->
        <h3 class="text-xl font-light mb-2 text-center">
            <span class="text-violet-400 font-medium">Simulaciones</span> Individuales
        </h3>
        <p class="text-gray-600 text-sm text-center mb-8">27 visualizaciones autocontenidas en Canvas 2D</p>

        <!-- Grid de Simulaciones -->
        <section class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-16">

            <!-- Mandelbrot -->
            <a href="mandelbrot.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-mandelbrot" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-violet-500/20 text-violet-400">Fractales</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Conjunto de Mandelbrot</h3>
                        <p class="text-gray-500 text-sm mb-3">Explora el fractal más famoso con zoom infinito. Renderizado pixel por pixel con mapa de colores HSV basado en velocidad de escape.</p>
                        <div class="equation text-violet-400/70 text-sm mb-4">z_{n+1} = z_n² + c</div>
                        <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                            Explorar Fractal →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Juego del Caos -->
            <a href="juego-caos.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-caos" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-violet-500/20 text-violet-400">Fractales</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Juego del Caos</h3>
                        <p class="text-gray-500 text-sm mb-3">Puntos aleatorios que mágicamente crean el triángulo de Sierpinski. La simplicidad genera complejidad infinita.</p>
                        <div class="equation text-violet-400/70 text-sm mb-4">P_{n+1} = (P_n + V_k) / 2</div>
                        <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                            Ver Emergencia →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Fourier Epicycles -->
            <a href="fourier-epicycles.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-fourier" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Cálculo</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Dibujo con Fourier</h3>
                        <p class="text-gray-500 text-sm mb-3">Dibuja cualquier forma y observa cómo los epiciclos giratorios la recrean. La magia de la Transformada Discreta de Fourier.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">X_k = Σ x_n · e^{-2πikn/N}</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Dibujar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Taylor Series -->
            <a href="taylor.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-taylor" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Cálculo</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Series de Taylor</h3>
                        <p class="text-gray-500 text-sm mb-3">Observa cómo los polinomios aproximan funciones trascendentes. Agrega términos y ve la convergencia en tiempo real.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">sin(x) ≈ x - x³/3! + x⁵/5! - ...</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Aproximar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Riemann Sums -->
            <a href="riemann.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-riemann" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Cálculo</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Sumas de Riemann</h3>
                        <p class="text-gray-500 text-sm mb-3">Visualiza la integral como límite de sumas. Rectángulos que convergen al área exacta bajo la curva.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">∫f(x)dx ≈ Σ f(xᵢ)Δx</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Integrar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Vector Field -->
            <a href="vector-field.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-vectorfield" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-yellow-500/20 text-yellow-400">Geometría</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Campo Vectorial</h3>
                        <p class="text-gray-500 text-sm mb-3">Partículas que fluyen siguiendo ecuaciones diferenciales. Visualiza rotacional, divergencia y puntos singulares.</p>
                        <div class="equation text-yellow-400/70 text-sm mb-4">dx/dt = f(x,y), dy/dt = g(x,y)</div>
                        <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                            Fluir →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Transform Matrix -->
            <a href="transform-matrix.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-matrix" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-yellow-500/20 text-yellow-400">Álgebra Lineal</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Transformaciones 2D</h3>
                        <p class="text-gray-500 text-sm mb-3">Arrastra los vectores base î y ĵ para ver cómo una matriz 2x2 distorsiona el espacio. Rotación, escala, shear.</p>
                        <div class="equation text-yellow-400/70 text-sm mb-4">[x', y'] = [a b; c d] · [x, y]</div>
                        <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                            Transformar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Ulam Spiral -->
            <a href="ulam-spiral.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-ulam" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-cyan-500/20 text-cyan-400">Números</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Espiral de Ulam</h3>
                        <p class="text-gray-500 text-sm mb-3">Los números primos organizados en espiral revelan patrones diagonales misteriosos. Orden en el aparente caos.</p>
                        <div class="equation text-cyan-400/70 text-sm mb-4">n ∈ P → pixel iluminado</div>
                        <span class="block w-full text-center py-2 bg-cyan-500/10 text-cyan-400 rounded-lg hover:bg-cyan-500/20 transition text-sm font-medium">
                            Descubrir →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Collatz -->
            <a href="collatz-tree.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-collatz" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-cyan-500/20 text-cyan-400">Números</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Árbol de Collatz</h3>
                        <p class="text-gray-500 text-sm mb-3">La conjetura 3n+1 visualizada como un árbol orgánico. ¿Todas las ramas llegan al 1? Nadie lo ha probado.</p>
                        <div class="equation text-cyan-400/70 text-sm mb-4">n → n/2 ó 3n+1</div>
                        <span class="block w-full text-center py-2 bg-cyan-500/10 text-cyan-400 rounded-lg hover:bg-cyan-500/20 transition text-sm font-medium">
                            Explorar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Voronoi -->
            <a href="voronoi.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-voronoi" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-yellow-500/20 text-yellow-400">Geometría</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Diagrama de Voronoi</h3>
                        <p class="text-gray-500 text-sm mb-3">Regiones de proximidad que se ajustan en tiempo real. Mueve los puntos y observa cómo el espacio se particiona.</p>
                        <div class="equation text-yellow-400/70 text-sm mb-4">V(p) = {x : d(x,p) ≤ d(x,q)}</div>
                        <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                            Particionar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Monte Carlo Pi -->
            <a href="montecarlo-pi.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-montecarlo" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-lime-500/20 text-lime-400">Probabilidad</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Monte Carlo: π</h3>
                        <p class="text-gray-500 text-sm mb-3">Estima π lanzando puntos aleatorios. La proporción dentro del círculo converge a π/4. Probabilidad en acción.</p>
                        <div class="equation text-lime-400/70 text-sm mb-4">π ≈ 4 · (puntos en círculo / total)</div>
                        <span class="block w-full text-center py-2 bg-lime-500/10 text-lime-400 rounded-lg hover:bg-lime-500/20 transition text-sm font-medium">
                            Estimar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Game of Life -->
            <a href="game-of-life.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-life" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-lime-500/20 text-lime-400">Autómatas</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Game of Life</h3>
                        <p class="text-gray-500 text-sm mb-3">El autómata celular de Conway. Reglas simples generan comportamiento complejo: gliders, osciladores, naves espaciales.</p>
                        <div class="equation text-lime-400/70 text-sm mb-4">B3/S23: nace con 3, sobrevive con 2-3</div>
                        <span class="block w-full text-center py-2 bg-lime-500/10 text-lime-400 rounded-lg hover:bg-lime-500/20 transition text-sm font-medium">
                            Simular →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Galton Board -->
            <a href="galton-board.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-galton" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-lime-500/20 text-lime-400">Probabilidad</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Tablero de Galton</h3>
                        <p class="text-gray-500 text-sm mb-3">Bolitas cayendo entre clavijas forman la distribución normal. La curva de campana emerge del azar.</p>
                        <div class="equation text-lime-400/70 text-sm mb-4">P(k) = C(n,k) · p^k · (1-p)^{n-k}</div>
                        <span class="block w-full text-center py-2 bg-lime-500/10 text-lime-400 rounded-lg hover:bg-lime-500/20 transition text-sm font-medium">
                            Observar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Lorenz Attractor -->
            <a href="lorenz-attractor.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-lorenz" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-violet-500/20 text-violet-400">Caos</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Atractor de Lorenz</h3>
                        <p class="text-gray-500 text-sm mb-3">El efecto mariposa en 3D. Un sistema determinista con comportamiento impredecible. Caos matemático puro.</p>
                        <div class="equation text-violet-400/70 text-sm mb-4">dx/dt = σ(y-x), dy/dt = x(ρ-z)-y</div>
                        <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                            Ver Caos →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Double Pendulum -->
            <a href="double-pendulum.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-pendulum" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-violet-500/20 text-violet-400">Caos</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Péndulo Doble</h3>
                        <p class="text-gray-500 text-sm mb-3">Sensibilidad extrema a condiciones iniciales. Dos péndulos idénticos divergen exponencialmente. El caos es inevitable.</p>
                        <div class="equation text-violet-400/70 text-sm mb-4">L = T - V, θ₁'' = f(θ₁, θ₂, ...)</div>
                        <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                            Comparar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Disco de Poincaré -->
            <a href="poincare-disk.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-poincare" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-orange-500/20 text-orange-400">Geometría Hiperbólica</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Disco de Poincaré</h3>
                        <p class="text-gray-500 text-sm mb-3">Explora el plano hiperbólico donde hay infinitas paralelas. Teselaciones {p,q} como las de M.C. Escher.</p>
                        <div class="equation text-orange-400/70 text-sm mb-4">ds² = 4(dx²+dy²)/(1-r²)²</div>
                        <span class="block w-full text-center py-2 bg-orange-500/10 text-orange-400 rounded-lg hover:bg-orange-500/20 transition text-sm font-medium">
                            Teselar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Domain Coloring -->
            <a href="domain-coloring.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-domain" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Análisis Complejo</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Domain Coloring</h3>
                        <p class="text-gray-500 text-sm mb-3">Visualiza funciones complejas con colores. Ceros, polos y estructuras de z², sin(z), Γ(z) y más.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">f(z) = u(x,y) + iv(x,y)</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Colorear →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Autómatas Elementales -->
            <a href="automatas-elementales.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-automata" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-lime-500/20 text-lime-400">Autómatas</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Autómatas Elementales</h3>
                        <p class="text-gray-500 text-sm mb-3">Las 256 reglas de Wolfram. La Regla 110 es Turing-completa. Caos, periodicidad y complejidad emergente.</p>
                        <div class="equation text-lime-400/70 text-sm mb-4">a[i]' = f(a[i-1], a[i], a[i+1])</div>
                        <span class="block w-full text-center py-2 bg-lime-500/10 text-lime-400 rounded-lg hover:bg-lime-500/20 transition text-sm font-medium">
                            Generar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Problema de 3 Cuerpos -->
            <a href="three-body.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-threebody" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-violet-500/20 text-violet-400">Caos</span><span class="stl-badge">3D Print</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Problema de 3 Cuerpos</h3>
                        <p class="text-gray-500 text-sm mb-3">Gravitación newtoniana sin solución analítica. Órbitas periódicas: Figura 8, Lagrange, Mariposa y más.</p>
                        <div class="equation text-violet-400/70 text-sm mb-4">F = Gm₁m₂/r², sistema caótico</div>
                        <span class="block w-full text-center py-2 bg-violet-500/10 text-violet-400 rounded-lg hover:bg-violet-500/20 transition text-sm font-medium">
                            Orbitar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Banda de Möbius -->
            <a href="mobius-strip.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-mobius" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-orange-500/20 text-orange-400">Topología</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Banda de Möbius</h3>
                        <p class="text-gray-500 text-sm mb-3">Superficie no orientable con un solo lado y un solo borde. Explora también Klein y el Toro en 3D.</p>
                        <div class="equation text-orange-400/70 text-sm mb-4">x = (1+v·cos(u/2))·cos(u)</div>
                        <span class="block w-full text-center py-2 bg-orange-500/10 text-orange-400 rounded-lg hover:bg-orange-500/20 transition text-sm font-medium">
                            Rotar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Nudos Matemáticos -->
            <a href="mathematical-knots.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-knots" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-orange-500/20 text-orange-400">Topología</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Nudos Matemáticos</h3>
                        <p class="text-gray-500 text-sm mb-3">Trefoil, Figura 8, Cinquefoil y más. Teoría de nudos en 3D con tubos renderizados y rotación interactiva.</p>
                        <div class="equation text-orange-400/70 text-sm mb-4">3₁, 4₁, 5₁... invariantes topológicos</div>
                        <span class="block w-full text-center py-2 bg-orange-500/10 text-orange-400 rounded-lg hover:bg-orange-500/20 transition text-sm font-medium">
                            Anudar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Grupos de Simetría -->
            <a href="symmetry-groups.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-symmetry" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-yellow-500/20 text-yellow-400">Geometría</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Grupos de Simetría</h3>
                        <p class="text-gray-500 text-sm mb-3">Los 17 grupos de wallpaper. Rotaciones, reflexiones y deslizamientos. El arte islámico y Escher.</p>
                        <div class="equation text-yellow-400/70 text-sm mb-4">p1, p4m, p6m... 17 grupos</div>
                        <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                            Simetrizar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Trigonometría -->
            <a href="trigonometria.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-trig" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-orange-500/20 text-orange-400">Geometría</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Trigonometría</h3>
                        <p class="text-gray-500 text-sm mb-3">El círculo unitario y las funciones que conectan ángulos con distancias. Seno, coseno, tangente y ondas.</p>
                        <div class="equation text-orange-400/70 text-sm mb-4">sin²θ + cos²θ = 1</div>
                        <span class="block w-full text-center py-2 bg-orange-500/10 text-orange-400 rounded-lg hover:bg-orange-500/20 transition text-sm font-medium">
                            Explorar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Probabilidad -->
            <a href="probabilidad.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-prob" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-emerald-500/20 text-emerald-400">Estadística</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Probabilidad</h3>
                        <p class="text-gray-500 text-sm mb-3">Explora distribuciones de probabilidad: Normal, Poisson, Binomial, Beta y más. Muestreo y ley de los grandes números.</p>
                        <div class="equation text-emerald-400/70 text-sm mb-4">P(x) = (1/σ√2π) e^(-(x-μ)²/2σ²)</div>
                        <span class="block w-full text-center py-2 bg-emerald-500/10 text-emerald-400 rounded-lg hover:bg-emerald-500/20 transition text-sm font-medium">
                            Muestrear →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Funciones Matemáticas -->
            <a href="funciones.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-func" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Cálculo</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Funciones Matemáticas</h3>
                        <p class="text-gray-500 text-sm mb-3">Explorador de funciones con transformaciones. Visualiza derivadas, integrales y rectas tangentes interactivas.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">y = a·f(b(x-h)) + k</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Explorar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Geometría 3D -->
            <a href="geometria-3d.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-geo3d" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-yellow-500/20 text-yellow-400">Geometría</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Geometría 3D</h3>
                        <p class="text-gray-500 text-sm mb-3">Explora sólidos platónicos y superficies de revolución. Volumen, área, vértices, aristas y secciones.</p>
                        <div class="equation text-yellow-400/70 text-sm mb-4">V - A + C = 2</div>
                        <span class="block w-full text-center py-2 bg-yellow-500/10 text-yellow-400 rounded-lg hover:bg-yellow-500/20 transition text-sm font-medium">
                            Explorar →
                        </span>
                    </div>
                </div>
            </a>

            <!-- Ecuaciones Diferenciales -->
            <a href="ecuaciones-diferenciales.html" class="card-link">
                <div class="card relative bg-gray-950 border border-gray-900 rounded-2xl overflow-hidden">
                    <div class="card-border"></div>
                    <div class="p-4">
                        <canvas id="preview-edo" class="preview-canvas w-full h-40 bg-black mb-4"></canvas>
                        <span class="category-tag bg-pink-500/20 text-pink-400">Cálculo</span>
                        <h3 class="text-lg font-medium mb-1 mt-2">Ecuaciones Diferenciales</h3>
                        <p class="text-gray-500 text-sm mb-3">Visualiza campos de pendientes y soluciones. Euler, RK4, osciladores, Lotka-Volterra y más.</p>
                        <div class="equation text-pink-400/70 text-sm mb-4">dy/dx = f(x, y)</div>
                        <span class="block w-full text-center py-2 bg-pink-500/10 text-pink-400 rounded-lg hover:bg-pink-500/20 transition text-sm font-medium">
                            Resolver →
                        </span>
                    </div>
                </div>
            </a>

        </section>

        <!-- Tech Stack -->
        <section class="text-center">
            <h3 class="text-lg font-medium mb-4 text-gray-500">Tecnologías</h3>
            <div class="flex flex-wrap justify-center gap-3">
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">Canvas 2D</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">Three.js</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">WebGL</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">KaTeX</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">DFT</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">RK4</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">Conway Operators</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">4D Projection</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">Lyapunov</span>
                <span class="px-3 py-1.5 bg-gray-900 rounded-full text-sm text-gray-400 mono">Wolfram Rules</span>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="border-t border-gray-900 py-6 mt-12">
        <div class="max-w-6xl mx-auto px-6 text-center text-gray-600 text-sm mono">
            Math Visual Lab · Donde los algoritmos cobran vida
        </div>
    </footer>

    <script>
        const previews = {};
        let time = 0;

        function initPreviews() {
            // Mandelbrot
            const mandelbrot = document.getElementById('preview-mandelbrot');
            if (mandelbrot) {
                previews.mandelbrot = {
                    ctx: mandelbrot.getContext('2d'),
                    w: mandelbrot.width = mandelbrot.offsetWidth * 2,
                    h: mandelbrot.height = mandelbrot.offsetHeight * 2,
                    rendered: false
                };
                renderMiniMandelbrot(previews.mandelbrot);
            }

            // Juego del Caos
            const caos = document.getElementById('preview-caos');
            if (caos) {
                previews.caos = {
                    ctx: caos.getContext('2d'),
                    w: caos.width = caos.offsetWidth * 2,
                    h: caos.height = caos.offsetHeight * 2,
                    points: [],
                    current: { x: 0.5, y: 0.5 }
                };
            }

            // Fourier
            const fourier = document.getElementById('preview-fourier');
            if (fourier) {
                previews.fourier = {
                    ctx: fourier.getContext('2d'),
                    w: fourier.width = fourier.offsetWidth * 2,
                    h: fourier.height = fourier.offsetHeight * 2,
                    phase: 0
                };
            }

            // Taylor
            const taylor = document.getElementById('preview-taylor');
            if (taylor) {
                previews.taylor = {
                    ctx: taylor.getContext('2d'),
                    w: taylor.width = taylor.offsetWidth * 2,
                    h: taylor.height = taylor.offsetHeight * 2
                };
            }

            // Riemann
            const riemann = document.getElementById('preview-riemann');
            if (riemann) {
                previews.riemann = {
                    ctx: riemann.getContext('2d'),
                    w: riemann.width = riemann.offsetWidth * 2,
                    h: riemann.height = riemann.offsetHeight * 2
                };
            }

            // Vector Field
            const vectorfield = document.getElementById('preview-vectorfield');
            if (vectorfield) {
                const particles = [];
                for (let i = 0; i < 50; i++) {
                    particles.push({ x: Math.random(), y: Math.random(), age: Math.random() * 100 });
                }
                previews.vectorfield = {
                    ctx: vectorfield.getContext('2d'),
                    w: vectorfield.width = vectorfield.offsetWidth * 2,
                    h: vectorfield.height = vectorfield.offsetHeight * 2,
                    particles
                };
            }

            // Matrix Transform
            const matrix = document.getElementById('preview-matrix');
            if (matrix) {
                previews.matrix = {
                    ctx: matrix.getContext('2d'),
                    w: matrix.width = matrix.offsetWidth * 2,
                    h: matrix.height = matrix.offsetHeight * 2
                };
            }

            // Ulam Spiral
            const ulam = document.getElementById('preview-ulam');
            if (ulam) {
                previews.ulam = {
                    ctx: ulam.getContext('2d'),
                    w: ulam.width = ulam.offsetWidth * 2,
                    h: ulam.height = ulam.offsetHeight * 2,
                    rendered: false
                };
                renderMiniUlam(previews.ulam);
            }

            // Collatz
            const collatz = document.getElementById('preview-collatz');
            if (collatz) {
                previews.collatz = {
                    ctx: collatz.getContext('2d'),
                    w: collatz.width = collatz.offsetWidth * 2,
                    h: collatz.height = collatz.offsetHeight * 2
                };
                renderMiniCollatz(previews.collatz);
            }

            // Voronoi
            const voronoi = document.getElementById('preview-voronoi');
            if (voronoi) {
                const points = [];
                for (let i = 0; i < 8; i++) {
                    points.push({
                        x: 0.15 + Math.random() * 0.7,
                        y: 0.15 + Math.random() * 0.7,
                        vx: (Math.random() - 0.5) * 0.005,
                        vy: (Math.random() - 0.5) * 0.005
                    });
                }
                previews.voronoi = {
                    ctx: voronoi.getContext('2d'),
                    w: voronoi.width = voronoi.offsetWidth * 2,
                    h: voronoi.height = voronoi.offsetHeight * 2,
                    points
                };
            }

            // Monte Carlo
            const montecarlo = document.getElementById('preview-montecarlo');
            if (montecarlo) {
                previews.montecarlo = {
                    ctx: montecarlo.getContext('2d'),
                    w: montecarlo.width = montecarlo.offsetWidth * 2,
                    h: montecarlo.height = montecarlo.offsetHeight * 2,
                    inside: 0,
                    total: 0,
                    points: []
                };
            }

            // Game of Life
            const life = document.getElementById('preview-life');
            if (life) {
                const size = 40;
                const grid = [];
                for (let i = 0; i < size; i++) {
                    grid[i] = [];
                    for (let j = 0; j < size; j++) {
                        grid[i][j] = Math.random() < 0.3 ? 1 : 0;
                    }
                }
                previews.life = {
                    ctx: life.getContext('2d'),
                    w: life.width = life.offsetWidth * 2,
                    h: life.height = life.offsetHeight * 2,
                    grid,
                    size
                };
            }

            // Galton
            const galton = document.getElementById('preview-galton');
            if (galton) {
                previews.galton = {
                    ctx: galton.getContext('2d'),
                    w: galton.width = galton.offsetWidth * 2,
                    h: galton.height = galton.offsetHeight * 2,
                    balls: [],
                    bins: new Array(15).fill(0)
                };
            }

            // Lorenz
            const lorenz = document.getElementById('preview-lorenz');
            if (lorenz) {
                previews.lorenz = {
                    ctx: lorenz.getContext('2d'),
                    w: lorenz.width = lorenz.offsetWidth * 2,
                    h: lorenz.height = lorenz.offsetHeight * 2,
                    x: 1, y: 1, z: 1,
                    trail: []
                };
            }

            // Double Pendulum
            const pendulum = document.getElementById('preview-pendulum');
            if (pendulum) {
                previews.pendulum = {
                    ctx: pendulum.getContext('2d'),
                    w: pendulum.width = pendulum.offsetWidth * 2,
                    h: pendulum.height = pendulum.offsetHeight * 2,
                    theta1: Math.PI / 2, theta2: Math.PI / 2,
                    omega1: 0, omega2: 0,
                    trail: []
                };
            }

            // Poincaré Disk
            const poincare = document.getElementById('preview-poincare');
            if (poincare) {
                previews.poincare = {
                    ctx: poincare.getContext('2d'),
                    w: poincare.width = poincare.offsetWidth * 2,
                    h: poincare.height = poincare.offsetHeight * 2,
                    rendered: false
                };
                renderMiniPoincare(previews.poincare);
            }

            // Domain Coloring
            const domain = document.getElementById('preview-domain');
            if (domain) {
                previews.domain = {
                    ctx: domain.getContext('2d'),
                    w: domain.width = domain.offsetWidth * 2,
                    h: domain.height = domain.offsetHeight * 2,
                    rendered: false
                };
                renderMiniDomain(previews.domain);
            }

            // Autómatas Elementales
            const automata = document.getElementById('preview-automata');
            if (automata) {
                previews.automata = {
                    ctx: automata.getContext('2d'),
                    w: automata.width = automata.offsetWidth * 2,
                    h: automata.height = automata.offsetHeight * 2,
                    rendered: false
                };
                renderMiniAutomata(previews.automata);
            }

            // Three Body
            const threebody = document.getElementById('preview-threebody');
            if (threebody) {
                previews.threebody = {
                    ctx: threebody.getContext('2d'),
                    w: threebody.width = threebody.offsetWidth * 2,
                    h: threebody.height = threebody.offsetHeight * 2,
                    bodies: [
                        { x: -0.97000436, y: 0.24308753, vx: 0.466203685, vy: 0.43236573 },
                        { x: 0.97000436, y: -0.24308753, vx: 0.466203685, vy: 0.43236573 },
                        { x: 0, y: 0, vx: -0.93240737, vy: -0.86473146 }
                    ],
                    trails: [[], [], []]
                };
            }

            // Möbius Strip
            const mobius = document.getElementById('preview-mobius');
            if (mobius) {
                previews.mobius = {
                    ctx: mobius.getContext('2d'),
                    w: mobius.width = mobius.offsetWidth * 2,
                    h: mobius.height = mobius.offsetHeight * 2
                };
            }

            // Knots
            const knots = document.getElementById('preview-knots');
            if (knots) {
                previews.knots = {
                    ctx: knots.getContext('2d'),
                    w: knots.width = knots.offsetWidth * 2,
                    h: knots.height = knots.offsetHeight * 2
                };
            }

            // Symmetry Groups
            const symmetry = document.getElementById('preview-symmetry');
            if (symmetry) {
                previews.symmetry = {
                    ctx: symmetry.getContext('2d'),
                    w: symmetry.width = symmetry.offsetWidth * 2,
                    h: symmetry.height = symmetry.offsetHeight * 2,
                    rendered: false
                };
                renderMiniSymmetry(previews.symmetry);
            }

            // Trigonometría
            const trig = document.getElementById('preview-trig');
            if (trig) {
                previews.trig = {
                    ctx: trig.getContext('2d'),
                    w: trig.width = trig.offsetWidth * 2,
                    h: trig.height = trig.offsetHeight * 2,
                    angle: 0
                };
            }

            // Probabilidad
            const prob = document.getElementById('preview-prob');
            if (prob) {
                previews.prob = {
                    ctx: prob.getContext('2d'),
                    w: prob.width = prob.offsetWidth * 2,
                    h: prob.height = prob.offsetHeight * 2,
                    samples: []
                };
            }

            // Funciones Matemáticas
            const func = document.getElementById('preview-func');
            if (func) {
                previews.func = {
                    ctx: func.getContext('2d'),
                    w: func.width = func.offsetWidth * 2,
                    h: func.height = func.offsetHeight * 2,
                    phase: 0
                };
            }

            // Geometría 3D
            const geo3d = document.getElementById('preview-geo3d');
            if (geo3d) {
                previews.geo3d = {
                    ctx: geo3d.getContext('2d'),
                    w: geo3d.width = geo3d.offsetWidth * 2,
                    h: geo3d.height = geo3d.offsetHeight * 2,
                    angle: 0
                };
            }

            // Ecuaciones Diferenciales
            const edo = document.getElementById('preview-edo');
            if (edo) {
                previews.edo = {
                    ctx: edo.getContext('2d'),
                    w: edo.width = edo.offsetWidth * 2,
                    h: edo.height = edo.offsetHeight * 2,
                    rendered: false
                };
                renderMiniEDO(previews.edo);
            }

            // Platonic Lab - Rotating icosahedron
            const platonic = document.getElementById('preview-platonic');
            if (platonic) {
                const PHI = (1 + Math.sqrt(5)) / 2;
                previews.platonic = {
                    ctx: platonic.getContext('2d'),
                    w: platonic.width = platonic.offsetWidth * 2,
                    h: platonic.height = platonic.offsetHeight * 2,
                    angle: 0,
                    // Icosahedron vertices (3 golden rectangles)
                    vertices: [
                        [0, 1, PHI], [0, 1, -PHI], [0, -1, PHI], [0, -1, -PHI],
                        [1, PHI, 0], [1, -PHI, 0], [-1, PHI, 0], [-1, -PHI, 0],
                        [PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, 1], [-PHI, 0, -1]
                    ],
                    edges: [
                        [0,2],[0,4],[0,6],[0,8],[0,10],[2,5],[2,7],[2,8],[2,10],
                        [1,3],[1,4],[1,6],[1,9],[1,11],[3,5],[3,7],[3,9],[3,11],
                        [4,6],[4,8],[4,9],[5,7],[5,8],[5,9],[6,10],[6,11],[7,10],[7,11],
                        [8,9],[10,11]
                    ]
                };
            }

            // Chaos Lab - Lorenz attractor
            const chaos = document.getElementById('preview-chaos');
            if (chaos) {
                previews.chaos = {
                    ctx: chaos.getContext('2d'),
                    w: chaos.width = chaos.offsetWidth * 2,
                    h: chaos.height = chaos.offsetHeight * 2,
                    x: 0.1, y: 0, z: 0,
                    trail: []
                };
            }

            // Polytope XD - Rotating tesseract
            const polytope = document.getElementById('preview-polytope');
            if (polytope) {
                // 16 vertices of a tesseract (4D hypercube)
                const verts = [];
                for (let i = 0; i < 16; i++) {
                    verts.push([
                        (i & 1) ? 1 : -1,
                        (i & 2) ? 1 : -1,
                        (i & 4) ? 1 : -1,
                        (i & 8) ? 1 : -1
                    ]);
                }
                // Edges: connect vertices that differ in exactly one coordinate
                const edges = [];
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        let diff = 0;
                        for (let k = 0; k < 4; k++) diff += Math.abs(verts[i][k] - verts[j][k]);
                        if (diff === 2) edges.push([i, j]);
                    }
                }
                previews.polytope = {
                    ctx: polytope.getContext('2d'),
                    w: polytope.width = polytope.offsetWidth * 2,
                    h: polytope.height = polytope.offsetHeight * 2,
                    vertices: verts,
                    edges: edges,
                    angle: 0
                };
            }
        }

        function renderMiniMandelbrot(m) {
            const imgData = m.ctx.createImageData(m.w, m.h);
            const maxIter = 50;
            for (let py = 0; py < m.h; py++) {
                for (let px = 0; px < m.w; px++) {
                    const x0 = (px / m.w) * 3.5 - 2.5;
                    const y0 = (py / m.h) * 2 - 1;
                    let x = 0, y = 0, iter = 0;
                    while (x*x + y*y <= 4 && iter < maxIter) {
                        const xtemp = x*x - y*y + x0;
                        y = 2*x*y + y0;
                        x = xtemp;
                        iter++;
                    }
                    const idx = (py * m.w + px) * 4;
                    if (iter === maxIter) {
                        imgData.data[idx] = 0;
                        imgData.data[idx + 1] = 0;
                        imgData.data[idx + 2] = 0;
                    } else {
                        const hue = (iter / maxIter) * 360;
                        const [r, g, b] = hsvToRgb(hue, 0.8, 0.9);
                        imgData.data[idx] = r;
                        imgData.data[idx + 1] = g;
                        imgData.data[idx + 2] = b;
                    }
                    imgData.data[idx + 3] = 255;
                }
            }
            m.ctx.putImageData(imgData, 0, 0);
            m.rendered = true;
        }

        function renderMiniUlam(u) {
            u.ctx.fillStyle = '#000';
            u.ctx.fillRect(0, 0, u.w, u.h);

            const cx = Math.floor(u.w / 2);
            const cy = Math.floor(u.h / 2);
            const pixelSize = 2;
            let x = 0, y = 0, dx = 1, dy = 0;
            let steps = 1, stepCount = 0, turnCount = 0;

            for (let n = 1; n < 5000; n++) {
                if (isPrime(n)) {
                    u.ctx.fillStyle = '#22d3ee';
                    u.ctx.fillRect(cx + x * pixelSize, cy + y * pixelSize, pixelSize, pixelSize);
                }
                x += dx; y += dy;
                stepCount++;
                if (stepCount === steps) {
                    stepCount = 0;
                    const temp = dx;
                    dx = -dy; dy = temp;
                    turnCount++;
                    if (turnCount === 2) {
                        turnCount = 0;
                        steps++;
                    }
                }
            }
            u.rendered = true;
        }

        function renderMiniCollatz(c) {
            c.ctx.fillStyle = '#000';
            c.ctx.fillRect(0, 0, c.w, c.h);

            c.ctx.strokeStyle = '#a855f720';
            c.ctx.lineWidth = 1;

            for (let start = 2; start < 100; start++) {
                let n = start;
                let x = c.w / 2;
                let y = c.h - 20;
                let angle = -Math.PI / 2;

                c.ctx.beginPath();
                c.ctx.moveTo(x, y);

                while (n > 1) {
                    if (n % 2 === 0) {
                        angle -= 0.1;
                        n = n / 2;
                    } else {
                        angle += 0.1;
                        n = 3 * n + 1;
                    }
                    x += Math.cos(angle) * 3;
                    y += Math.sin(angle) * 3;
                    c.ctx.lineTo(x, y);
                }
                c.ctx.stroke();
            }
        }

        function renderMiniPoincare(p) {
            p.ctx.fillStyle = '#000';
            p.ctx.fillRect(0, 0, p.w, p.h);

            const cx = p.w / 2, cy = p.h / 2;
            const R = Math.min(p.w, p.h) / 2 - 10;

            // Disk boundary
            p.ctx.strokeStyle = '#f9731640';
            p.ctx.lineWidth = 2;
            p.ctx.beginPath();
            p.ctx.arc(cx, cy, R, 0, Math.PI * 2);
            p.ctx.stroke();

            // Hyperbolic lines (geodesics as arcs)
            p.ctx.strokeStyle = '#f97316';
            p.ctx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const r = R * 0.8;
                p.ctx.beginPath();
                p.ctx.arc(cx + Math.cos(angle) * r * 1.5, cy + Math.sin(angle) * r * 1.5, r, 0, Math.PI * 2);
                p.ctx.stroke();
            }

            // Clip to disk
            p.ctx.globalCompositeOperation = 'destination-in';
            p.ctx.beginPath();
            p.ctx.arc(cx, cy, R, 0, Math.PI * 2);
            p.ctx.fill();
            p.ctx.globalCompositeOperation = 'source-over';

            p.rendered = true;
        }

        function renderMiniDomain(d) {
            const imgData = d.ctx.createImageData(d.w, d.h);

            for (let py = 0; py < d.h; py++) {
                for (let px = 0; px < d.w; px++) {
                    const x = (px / d.w - 0.5) * 4;
                    const y = (py / d.h - 0.5) * 4;

                    // z^2 function
                    const re = x * x - y * y;
                    const im = 2 * x * y;

                    const arg = Math.atan2(im, re);
                    const mag = Math.sqrt(re * re + im * im);

                    const hue = ((arg + Math.PI) / (2 * Math.PI)) * 360;
                    const sat = 0.8;
                    const val = 1 - 1 / (1 + mag * 0.3);

                    const [r, g, b] = hsvToRgb(hue, sat, val);
                    const idx = (py * d.w + px) * 4;
                    imgData.data[idx] = r;
                    imgData.data[idx + 1] = g;
                    imgData.data[idx + 2] = b;
                    imgData.data[idx + 3] = 255;
                }
            }
            d.ctx.putImageData(imgData, 0, 0);
            d.rendered = true;
        }

        function renderMiniAutomata(a) {
            a.ctx.fillStyle = '#000';
            a.ctx.fillRect(0, 0, a.w, a.h);

            const rule = 110;
            const cellSize = 4;
            const cols = Math.floor(a.w / cellSize);
            const rows = Math.floor(a.h / cellSize);

            let current = new Array(cols).fill(0);
            current[Math.floor(cols / 2)] = 1;

            a.ctx.fillStyle = '#a3e635';

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (current[col] === 1) {
                        a.ctx.fillRect(col * cellSize, row * cellSize, cellSize - 1, cellSize - 1);
                    }
                }

                const next = new Array(cols).fill(0);
                for (let col = 0; col < cols; col++) {
                    const left = current[(col - 1 + cols) % cols];
                    const center = current[col];
                    const right = current[(col + 1) % cols];
                    const pattern = (left << 2) | (center << 1) | right;
                    next[col] = (rule >> pattern) & 1;
                }
                current = next;
            }
            a.rendered = true;
        }

        function renderMiniSymmetry(s) {
            s.ctx.fillStyle = '#000';
            s.ctx.fillRect(0, 0, s.w, s.h);

            const cellSize = 30;
            const cols = Math.ceil(s.w / cellSize);
            const rows = Math.ceil(s.h / cellSize);

            // p4m wallpaper group
            s.ctx.fillStyle = '#facc15';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cx = col * cellSize + cellSize / 2;
                    const cy = row * cellSize + cellSize / 2;

                    // Draw motif with 4-fold rotational symmetry
                    for (let r = 0; r < 4; r++) {
                        const angle = (r / 4) * Math.PI * 2;
                        s.ctx.beginPath();
                        s.ctx.moveTo(cx, cy);
                        s.ctx.lineTo(cx + Math.cos(angle) * 10, cy + Math.sin(angle) * 10);
                        s.ctx.lineTo(cx + Math.cos(angle + 0.3) * 6, cy + Math.sin(angle + 0.3) * 6);
                        s.ctx.closePath();
                        s.ctx.fill();
                    }
                }
            }
            s.rendered = true;
        }

        function renderMiniEDO(e) {
            e.ctx.fillStyle = '#030712';
            e.ctx.fillRect(0, 0, e.w, e.h);

            const gridSize = 20;
            const lineLength = 8;

            // Draw slope field for dy/dx = 0.5*y (exponential growth)
            for (let px = gridSize; px < e.w; px += gridSize) {
                for (let py = gridSize; py < e.h; py += gridSize) {
                    const x = (px / e.w - 0.5) * 10;
                    const y = (0.5 - py / e.h) * 6;
                    const slope = 0.5 * y;

                    const angle = Math.atan(slope);
                    const dx = Math.cos(angle) * lineLength / 2;
                    const dy = Math.sin(angle) * lineLength / 2;

                    const intensity = Math.min(Math.abs(slope), 2) / 2;
                    e.ctx.strokeStyle = `rgba(168, 85, 247, ${0.2 + intensity * 0.4})`;
                    e.ctx.lineWidth = 1;
                    e.ctx.beginPath();
                    e.ctx.moveTo(px - dx, py + dy);
                    e.ctx.lineTo(px + dx, py - dy);
                    e.ctx.stroke();
                }
            }

            // Draw a few solution curves
            const solutions = [
                { y0: 1, color: '#22d3ee' },
                { y0: -1, color: '#f472b6' },
                { y0: 2, color: '#a3e635' }
            ];

            solutions.forEach(({ y0, color }) => {
                e.ctx.strokeStyle = color;
                e.ctx.lineWidth = 2;
                e.ctx.beginPath();

                let y = y0;
                for (let px = 0; px < e.w; px++) {
                    const x = (px / e.w - 0.5) * 10;
                    y = y0 * Math.exp(0.5 * x);
                    const py = e.h * (0.5 - y / 6);

                    if (py < -50 || py > e.h + 50) continue;

                    if (px === 0 || (px > 0 && Math.abs(y) > 10)) {
                        e.ctx.moveTo(px, py);
                    } else {
                        e.ctx.lineTo(px, py);
                    }
                }
                e.ctx.stroke();
            });

            e.rendered = true;
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        function animate() {
            time += 0.02;

            // Juego del Caos (Sierpinski)
            if (previews.caos) {
                const c = previews.caos;
                if (c.points.length === 0) {
                    c.ctx.fillStyle = '#000';
                    c.ctx.fillRect(0, 0, c.w, c.h);
                }
                const vertices = [
                    { x: 0.5, y: 0.1 },
                    { x: 0.1, y: 0.9 },
                    { x: 0.9, y: 0.9 }
                ];
                for (let i = 0; i < 50; i++) {
                    const v = vertices[Math.floor(Math.random() * 3)];
                    c.current.x = (c.current.x + v.x) / 2;
                    c.current.y = (c.current.y + v.y) / 2;
                    c.ctx.fillStyle = '#a855f7';
                    c.ctx.fillRect(c.current.x * c.w, c.current.y * c.h, 1, 1);
                }
            }

            // Fourier Epicycles
            if (previews.fourier) {
                const f = previews.fourier;
                f.ctx.fillStyle = '#000';
                f.ctx.fillRect(0, 0, f.w, f.h);

                const cx = f.w / 2, cy = f.h / 2;
                let x = cx, y = cy;
                const harmonics = [
                    { amp: 50, freq: 1 },
                    { amp: 25, freq: 2 },
                    { amp: 15, freq: 3 },
                    { amp: 10, freq: 5 }
                ];

                f.ctx.strokeStyle = '#f472b630';
                f.ctx.lineWidth = 1;

                for (const h of harmonics) {
                    f.ctx.beginPath();
                    f.ctx.arc(x, y, h.amp, 0, Math.PI * 2);
                    f.ctx.stroke();

                    const angle = h.freq * f.phase;
                    const nx = x + h.amp * Math.cos(angle);
                    const ny = y + h.amp * Math.sin(angle);

                    f.ctx.strokeStyle = '#f472b6';
                    f.ctx.beginPath();
                    f.ctx.moveTo(x, y);
                    f.ctx.lineTo(nx, ny);
                    f.ctx.stroke();
                    f.ctx.strokeStyle = '#f472b630';

                    x = nx; y = ny;
                }

                f.ctx.fillStyle = '#f472b6';
                f.ctx.beginPath();
                f.ctx.arc(x, y, 4, 0, Math.PI * 2);
                f.ctx.fill();

                f.phase += 0.03;
            }

            // Taylor Series
            if (previews.taylor) {
                const t = previews.taylor;
                t.ctx.fillStyle = '#000';
                t.ctx.fillRect(0, 0, t.w, t.h);

                const cy = t.h / 2;
                const scale = 30;
                const terms = Math.floor((Math.sin(time * 0.5) + 1) * 4) + 1;

                // Actual sin(x)
                t.ctx.strokeStyle = '#f472b640';
                t.ctx.lineWidth = 2;
                t.ctx.beginPath();
                for (let px = 0; px < t.w; px++) {
                    const x = (px - t.w / 2) / scale;
                    const y = cy - Math.sin(x) * scale;
                    if (px === 0) t.ctx.moveTo(px, y);
                    else t.ctx.lineTo(px, y);
                }
                t.ctx.stroke();

                // Taylor approximation
                t.ctx.strokeStyle = '#22d3ee';
                t.ctx.lineWidth = 2;
                t.ctx.beginPath();
                for (let px = 0; px < t.w; px++) {
                    const x = (px - t.w / 2) / scale;
                    let taylorY = 0;
                    for (let n = 0; n < terms; n++) {
                        const sign = n % 2 === 0 ? 1 : -1;
                        taylorY += sign * Math.pow(x, 2*n + 1) / factorial(2*n + 1);
                    }
                    const y = cy - taylorY * scale;
                    if (px === 0) t.ctx.moveTo(px, y);
                    else t.ctx.lineTo(px, y);
                }
                t.ctx.stroke();
            }

            // Riemann Sums
            if (previews.riemann) {
                const r = previews.riemann;
                r.ctx.fillStyle = '#000';
                r.ctx.fillRect(0, 0, r.w, r.h);

                const n = Math.floor((Math.sin(time * 0.3) + 1) * 10) + 3;
                const dx = r.w / n;

                // Function curve
                r.ctx.strokeStyle = '#f472b6';
                r.ctx.lineWidth = 2;
                r.ctx.beginPath();
                for (let px = 0; px < r.w; px++) {
                    const x = px / r.w;
                    const y = r.h - (Math.sin(x * Math.PI) * 0.7 + 0.1) * r.h;
                    if (px === 0) r.ctx.moveTo(px, y);
                    else r.ctx.lineTo(px, y);
                }
                r.ctx.stroke();

                // Rectangles
                for (let i = 0; i < n; i++) {
                    const x = (i + 0.5) / n;
                    const height = (Math.sin(x * Math.PI) * 0.7 + 0.1) * r.h;
                    r.ctx.fillStyle = '#f472b620';
                    r.ctx.strokeStyle = '#f472b6';
                    r.ctx.lineWidth = 1;
                    r.ctx.fillRect(i * dx, r.h - height, dx - 2, height);
                    r.ctx.strokeRect(i * dx, r.h - height, dx - 2, height);
                }
            }

            // Vector Field
            if (previews.vectorfield) {
                const v = previews.vectorfield;
                v.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                v.ctx.fillRect(0, 0, v.w, v.h);

                for (const p of v.particles) {
                    const fx = Math.sin(p.y * 5 + time);
                    const fy = Math.cos(p.x * 5 + time);
                    p.x += fx * 0.003;
                    p.y += fy * 0.003;
                    p.age++;

                    if (p.x < 0 || p.x > 1 || p.y < 0 || p.y > 1 || p.age > 100) {
                        p.x = Math.random();
                        p.y = Math.random();
                        p.age = 0;
                    }

                    const alpha = 1 - p.age / 100;
                    v.ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
                    v.ctx.fillRect(p.x * v.w, p.y * v.h, 2, 2);
                }
            }

            // Matrix Transform
            if (previews.matrix) {
                const m = previews.matrix;
                m.ctx.fillStyle = '#000';
                m.ctx.fillRect(0, 0, m.w, m.h);

                const cx = m.w / 2, cy = m.h / 2;
                const angle = time * 0.5;
                const scale = 0.8 + Math.sin(time) * 0.2;
                const a = Math.cos(angle) * scale;
                const b = -Math.sin(angle) * scale;
                const c = Math.sin(angle) * scale;
                const d = Math.cos(angle) * scale;

                m.ctx.strokeStyle = '#facc1530';
                m.ctx.lineWidth = 1;

                for (let i = -5; i <= 5; i++) {
                    m.ctx.beginPath();
                    const x1 = a * i * 15 + b * (-5) * 15;
                    const y1 = c * i * 15 + d * (-5) * 15;
                    const x2 = a * i * 15 + b * 5 * 15;
                    const y2 = c * i * 15 + d * 5 * 15;
                    m.ctx.moveTo(cx + x1, cy + y1);
                    m.ctx.lineTo(cx + x2, cy + y2);
                    m.ctx.stroke();

                    m.ctx.beginPath();
                    const x3 = a * (-5) * 15 + b * i * 15;
                    const y3 = c * (-5) * 15 + d * i * 15;
                    const x4 = a * 5 * 15 + b * i * 15;
                    const y4 = c * 5 * 15 + d * i * 15;
                    m.ctx.moveTo(cx + x3, cy + y3);
                    m.ctx.lineTo(cx + x4, cy + y4);
                    m.ctx.stroke();
                }

                // Basis vectors
                m.ctx.strokeStyle = '#ef4444';
                m.ctx.lineWidth = 3;
                m.ctx.beginPath();
                m.ctx.moveTo(cx, cy);
                m.ctx.lineTo(cx + a * 50, cy + c * 50);
                m.ctx.stroke();

                m.ctx.strokeStyle = '#22c55e';
                m.ctx.beginPath();
                m.ctx.moveTo(cx, cy);
                m.ctx.lineTo(cx + b * 50, cy + d * 50);
                m.ctx.stroke();
            }

            // Voronoi
            if (previews.voronoi) {
                const v = previews.voronoi;
                const imgData = v.ctx.createImageData(v.w, v.h);
                const colors = [
                    [168, 85, 247], [34, 211, 238], [163, 230, 53],
                    [244, 114, 182], [250, 204, 21], [239, 68, 68],
                    [59, 130, 246], [34, 197, 94]
                ];

                for (const p of v.points) {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0.1 || p.x > 0.9) p.vx *= -1;
                    if (p.y < 0.1 || p.y > 0.9) p.vy *= -1;
                }

                for (let py = 0; py < v.h; py += 4) {
                    for (let px = 0; px < v.w; px += 4) {
                        let minDist = Infinity;
                        let closest = 0;
                        for (let i = 0; i < v.points.length; i++) {
                            const dx = px / v.w - v.points[i].x;
                            const dy = py / v.h - v.points[i].y;
                            const dist = dx * dx + dy * dy;
                            if (dist < minDist) {
                                minDist = dist;
                                closest = i;
                            }
                        }
                        const col = colors[closest % colors.length];
                        for (let dy = 0; dy < 4; dy++) {
                            for (let dx = 0; dx < 4; dx++) {
                                const idx = ((py + dy) * v.w + (px + dx)) * 4;
                                imgData.data[idx] = col[0] * 0.3;
                                imgData.data[idx + 1] = col[1] * 0.3;
                                imgData.data[idx + 2] = col[2] * 0.3;
                                imgData.data[idx + 3] = 255;
                            }
                        }
                    }
                }
                v.ctx.putImageData(imgData, 0, 0);

                v.ctx.fillStyle = '#fff';
                for (const p of v.points) {
                    v.ctx.beginPath();
                    v.ctx.arc(p.x * v.w, p.y * v.h, 4, 0, Math.PI * 2);
                    v.ctx.fill();
                }
            }

            // Monte Carlo Pi
            if (previews.montecarlo) {
                const m = previews.montecarlo;
                if (m.total === 0) {
                    m.ctx.fillStyle = '#000';
                    m.ctx.fillRect(0, 0, m.w, m.h);
                    m.ctx.strokeStyle = '#a3e63530';
                    m.ctx.lineWidth = 2;
                    m.ctx.beginPath();
                    m.ctx.arc(m.w / 2, m.h / 2, Math.min(m.w, m.h) / 2 - 10, 0, Math.PI * 2);
                    m.ctx.stroke();
                }

                for (let i = 0; i < 10; i++) {
                    const x = Math.random();
                    const y = Math.random();
                    const dx = x - 0.5;
                    const dy = y - 0.5;
                    const inCircle = dx * dx + dy * dy <= 0.25;

                    m.total++;
                    if (inCircle) m.inside++;

                    m.ctx.fillStyle = inCircle ? '#a3e635' : '#ef4444';
                    m.ctx.fillRect(x * m.w, y * m.h, 2, 2);
                }

                if (m.total > 3000) {
                    m.total = 0;
                    m.inside = 0;
                }
            }

            // Game of Life
            if (previews.life && Math.floor(time * 5) % 3 === 0) {
                const l = previews.life;
                const newGrid = [];
                for (let i = 0; i < l.size; i++) {
                    newGrid[i] = [];
                    for (let j = 0; j < l.size; j++) {
                        let neighbors = 0;
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                if (di === 0 && dj === 0) continue;
                                const ni = (i + di + l.size) % l.size;
                                const nj = (j + dj + l.size) % l.size;
                                neighbors += l.grid[ni][nj];
                            }
                        }
                        if (l.grid[i][j] === 1) {
                            newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                        } else {
                            newGrid[i][j] = neighbors === 3 ? 1 : 0;
                        }
                    }
                }
                l.grid = newGrid;

                l.ctx.fillStyle = '#000';
                l.ctx.fillRect(0, 0, l.w, l.h);
                const cellW = l.w / l.size;
                const cellH = l.h / l.size;
                l.ctx.fillStyle = '#a3e635';
                for (let i = 0; i < l.size; i++) {
                    for (let j = 0; j < l.size; j++) {
                        if (l.grid[i][j] === 1) {
                            l.ctx.fillRect(j * cellW, i * cellH, cellW - 1, cellH - 1);
                        }
                    }
                }
            }

            // Galton Board
            if (previews.galton) {
                const g = previews.galton;
                g.ctx.fillStyle = '#000';
                g.ctx.fillRect(0, 0, g.w, g.h);

                // Add ball
                if (Math.random() < 0.1 && g.balls.length < 50) {
                    g.balls.push({ x: g.w / 2, y: 10, vx: 0, vy: 0 });
                }

                // Pegs
                const rows = 10;
                const pegSpacing = g.w / 15;
                g.ctx.fillStyle = '#a3e63540';
                for (let row = 0; row < rows; row++) {
                    const pegsInRow = row + 1;
                    const startX = g.w / 2 - (pegsInRow - 1) * pegSpacing / 2;
                    for (let p = 0; p < pegsInRow; p++) {
                        const px = startX + p * pegSpacing;
                        const py = 40 + row * 20;
                        g.ctx.beginPath();
                        g.ctx.arc(px, py, 3, 0, Math.PI * 2);
                        g.ctx.fill();
                    }
                }

                // Update balls
                for (let i = g.balls.length - 1; i >= 0; i--) {
                    const ball = g.balls[i];
                    ball.vy += 0.3;
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    // Bounce off pegs
                    for (let row = 0; row < rows; row++) {
                        const pegsInRow = row + 1;
                        const startX = g.w / 2 - (pegsInRow - 1) * pegSpacing / 2;
                        for (let p = 0; p < pegsInRow; p++) {
                            const px = startX + p * pegSpacing;
                            const py = 40 + row * 20;
                            const dx = ball.x - px;
                            const dy = ball.y - py;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 8) {
                                ball.vx = (Math.random() - 0.5) * 3;
                                ball.vy = Math.abs(ball.vy) * 0.5;
                                ball.y = py + 8;
                            }
                        }
                    }

                    // Remove at bottom and add to bins
                    if (ball.y > g.h - 30) {
                        const binIndex = Math.floor(ball.x / (g.w / 15));
                        if (binIndex >= 0 && binIndex < 15) {
                            g.bins[binIndex] = Math.min(g.bins[binIndex] + 1, 30);
                        }
                        g.balls.splice(i, 1);
                    }
                }

                // Draw balls
                g.ctx.fillStyle = '#a3e635';
                for (const ball of g.balls) {
                    g.ctx.beginPath();
                    g.ctx.arc(ball.x, ball.y, 4, 0, Math.PI * 2);
                    g.ctx.fill();
                }

                // Draw bins
                const binW = g.w / 15;
                for (let i = 0; i < 15; i++) {
                    const height = g.bins[i] * 3;
                    g.ctx.fillStyle = '#a3e63560';
                    g.ctx.fillRect(i * binW + 2, g.h - height, binW - 4, height);
                }
            }

            // Lorenz Attractor
            if (previews.lorenz) {
                const l = previews.lorenz;
                const sigma = 10, rho = 28, beta = 8/3;
                const dt = 0.01;

                for (let i = 0; i < 5; i++) {
                    const dx = sigma * (l.y - l.x);
                    const dy = l.x * (rho - l.z) - l.y;
                    const dz = l.x * l.y - beta * l.z;
                    l.x += dx * dt;
                    l.y += dy * dt;
                    l.z += dz * dt;
                    l.trail.push({ x: l.x, y: l.y, z: l.z });
                }

                if (l.trail.length > 500) l.trail.splice(0, 5);

                l.ctx.fillStyle = 'rgba(0,0,0,0.05)';
                l.ctx.fillRect(0, 0, l.w, l.h);

                const cx = l.w / 2, cy = l.h / 2;
                const scale = 4;
                const rotY = time * 0.2;

                if (l.trail.length > 1) {
                    l.ctx.beginPath();
                    for (let i = 0; i < l.trail.length; i++) {
                        const p = l.trail[i];
                        const rx = p.x * Math.cos(rotY) - p.z * Math.sin(rotY);
                        const px = cx + rx * scale;
                        const py = cy - p.y * scale + 50;
                        if (i === 0) l.ctx.moveTo(px, py);
                        else l.ctx.lineTo(px, py);
                    }
                    const hue = (time * 50) % 360;
                    l.ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                    l.ctx.lineWidth = 1;
                    l.ctx.stroke();
                }
            }

            // Double Pendulum
            if (previews.pendulum) {
                const p = previews.pendulum;
                const g = 9.8, m1 = 1, m2 = 1, l1 = 40, l2 = 40;
                const dt = 0.05;

                // Equations of motion (simplified)
                const num1 = -g * (2 * m1 + m2) * Math.sin(p.theta1);
                const num2 = -m2 * g * Math.sin(p.theta1 - 2 * p.theta2);
                const num3 = -2 * Math.sin(p.theta1 - p.theta2) * m2;
                const num4 = p.omega2 * p.omega2 * l2 + p.omega1 * p.omega1 * l1 * Math.cos(p.theta1 - p.theta2);
                const den = l1 * (2 * m1 + m2 - m2 * Math.cos(2 * p.theta1 - 2 * p.theta2));
                const alpha1 = (num1 + num2 + num3 * num4) / den;

                const num5 = 2 * Math.sin(p.theta1 - p.theta2);
                const num6 = p.omega1 * p.omega1 * l1 * (m1 + m2);
                const num7 = g * (m1 + m2) * Math.cos(p.theta1);
                const num8 = p.omega2 * p.omega2 * l2 * m2 * Math.cos(p.theta1 - p.theta2);
                const den2 = l2 * (2 * m1 + m2 - m2 * Math.cos(2 * p.theta1 - 2 * p.theta2));
                const alpha2 = (num5 * (num6 + num7 + num8)) / den2;

                p.omega1 += alpha1 * dt;
                p.omega2 += alpha2 * dt;
                p.theta1 += p.omega1 * dt;
                p.theta2 += p.omega2 * dt;

                const cx = p.w / 2, cy = p.h * 0.3;
                const x1 = cx + l1 * Math.sin(p.theta1);
                const y1 = cy + l1 * Math.cos(p.theta1);
                const x2 = x1 + l2 * Math.sin(p.theta2);
                const y2 = y1 + l2 * Math.cos(p.theta2);

                p.trail.push({ x: x2, y: y2 });
                if (p.trail.length > 200) p.trail.shift();

                p.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                p.ctx.fillRect(0, 0, p.w, p.h);

                // Trail
                if (p.trail.length > 1) {
                    p.ctx.beginPath();
                    for (let i = 0; i < p.trail.length; i++) {
                        const pt = p.trail[i];
                        if (i === 0) p.ctx.moveTo(pt.x, pt.y);
                        else p.ctx.lineTo(pt.x, pt.y);
                    }
                    p.ctx.strokeStyle = '#a855f7';
                    p.ctx.lineWidth = 1;
                    p.ctx.stroke();
                }

                // Rods
                p.ctx.strokeStyle = '#666';
                p.ctx.lineWidth = 2;
                p.ctx.beginPath();
                p.ctx.moveTo(cx, cy);
                p.ctx.lineTo(x1, y1);
                p.ctx.lineTo(x2, y2);
                p.ctx.stroke();

                // Masses
                p.ctx.fillStyle = '#a855f7';
                p.ctx.beginPath();
                p.ctx.arc(x1, y1, 8, 0, Math.PI * 2);
                p.ctx.fill();
                p.ctx.beginPath();
                p.ctx.arc(x2, y2, 8, 0, Math.PI * 2);
                p.ctx.fill();
            }

            // Three Body Problem
            if (previews.threebody) {
                const t = previews.threebody;
                t.ctx.fillStyle = 'rgba(0,0,0,0.05)';
                t.ctx.fillRect(0, 0, t.w, t.h);

                const G = 1;
                const dt = 0.01;
                const scale = 60;
                const cx = t.w / 2, cy = t.h / 2;

                // Update physics
                for (let step = 0; step < 3; step++) {
                    for (let i = 0; i < 3; i++) {
                        let ax = 0, ay = 0;
                        for (let j = 0; j < 3; j++) {
                            if (i !== j) {
                                const dx = t.bodies[j].x - t.bodies[i].x;
                                const dy = t.bodies[j].y - t.bodies[i].y;
                                const r = Math.sqrt(dx * dx + dy * dy) + 0.01;
                                ax += G * dx / (r * r * r);
                                ay += G * dy / (r * r * r);
                            }
                        }
                        t.bodies[i].vx += ax * dt;
                        t.bodies[i].vy += ay * dt;
                    }
                    for (let i = 0; i < 3; i++) {
                        t.bodies[i].x += t.bodies[i].vx * dt;
                        t.bodies[i].y += t.bodies[i].vy * dt;
                        t.trails[i].push({ x: t.bodies[i].x, y: t.bodies[i].y });
                        if (t.trails[i].length > 300) t.trails[i].shift();
                    }
                }

                // Draw trails
                const colors = ['#ef4444', '#22c55e', '#3b82f6'];
                for (let i = 0; i < 3; i++) {
                    if (t.trails[i].length > 1) {
                        t.ctx.beginPath();
                        for (let j = 0; j < t.trails[i].length; j++) {
                            const pt = t.trails[i][j];
                            const px = cx + pt.x * scale;
                            const py = cy + pt.y * scale;
                            if (j === 0) t.ctx.moveTo(px, py);
                            else t.ctx.lineTo(px, py);
                        }
                        t.ctx.strokeStyle = colors[i];
                        t.ctx.lineWidth = 1;
                        t.ctx.stroke();
                    }

                    // Draw body
                    t.ctx.fillStyle = colors[i];
                    t.ctx.beginPath();
                    t.ctx.arc(cx + t.bodies[i].x * scale, cy + t.bodies[i].y * scale, 5, 0, Math.PI * 2);
                    t.ctx.fill();
                }
            }

            // Möbius Strip
            if (previews.mobius) {
                const m = previews.mobius;
                m.ctx.fillStyle = '#000';
                m.ctx.fillRect(0, 0, m.w, m.h);

                const cx = m.w / 2, cy = m.h / 2;
                const R = 50, w = 20;
                const rotY = time * 0.5;
                const rotX = 0.3;

                const points = [];
                const uSteps = 60, vSteps = 10;

                for (let ui = 0; ui <= uSteps; ui++) {
                    for (let vi = 0; vi <= vSteps; vi++) {
                        const u = (ui / uSteps) * Math.PI * 2;
                        const v = (vi / vSteps - 0.5) * w;

                        // Möbius parametric equations
                        const x = (R + v * Math.cos(u / 2)) * Math.cos(u);
                        const y = (R + v * Math.cos(u / 2)) * Math.sin(u);
                        const z = v * Math.sin(u / 2);

                        // Rotate
                        const x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
                        const z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
                        const y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);

                        points.push({ x: cx + x1, y: cy + y1, z: z1 });
                    }
                }

                // Draw wireframe
                m.ctx.strokeStyle = '#f9731660';
                m.ctx.lineWidth = 1;
                for (let ui = 0; ui < uSteps; ui++) {
                    for (let vi = 0; vi < vSteps; vi++) {
                        const i = ui * (vSteps + 1) + vi;
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        const p3 = points[i + vSteps + 1];

                        m.ctx.beginPath();
                        m.ctx.moveTo(p1.x, p1.y);
                        m.ctx.lineTo(p2.x, p2.y);
                        m.ctx.stroke();

                        m.ctx.beginPath();
                        m.ctx.moveTo(p1.x, p1.y);
                        m.ctx.lineTo(p3.x, p3.y);
                        m.ctx.stroke();
                    }
                }
            }

            // Mathematical Knots (Trefoil)
            if (previews.knots) {
                const k = previews.knots;
                k.ctx.fillStyle = '#000';
                k.ctx.fillRect(0, 0, k.w, k.h);

                const cx = k.w / 2, cy = k.h / 2;
                const scale = 25;
                const rotY = time * 0.3;
                const rotX = 0.5;

                const points = [];
                const steps = 100;

                for (let i = 0; i <= steps; i++) {
                    const t = (i / steps) * Math.PI * 2;

                    // Trefoil knot parametric equations
                    const x = Math.sin(t) + 2 * Math.sin(2 * t);
                    const y = Math.cos(t) - 2 * Math.cos(2 * t);
                    const z = -Math.sin(3 * t);

                    // Rotate
                    const x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
                    const z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
                    const y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);

                    points.push({ x: cx + x1 * scale, y: cy + y1 * scale, z: z1 });
                }

                // Draw with depth shading
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const brightness = Math.floor(((p1.z + 3) / 6) * 100 + 50);

                    k.ctx.strokeStyle = `hsl(30, 80%, ${brightness}%)`;
                    k.ctx.lineWidth = 3;
                    k.ctx.beginPath();
                    k.ctx.moveTo(p1.x, p1.y);
                    k.ctx.lineTo(p2.x, p2.y);
                    k.ctx.stroke();
                }
            }

            // Trigonometría
            if (previews.trig) {
                const t = previews.trig;
                t.ctx.fillStyle = '#000';
                t.ctx.fillRect(0, 0, t.w, t.h);

                const cx = t.w / 2;
                const cy = t.h / 2;
                const radius = Math.min(t.w, t.h) * 0.35;

                // Circle
                t.ctx.strokeStyle = '#f97316';
                t.ctx.lineWidth = 2;
                t.ctx.beginPath();
                t.ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                t.ctx.stroke();

                // Axes
                t.ctx.strokeStyle = '#374151';
                t.ctx.lineWidth = 1;
                t.ctx.beginPath();
                t.ctx.moveTo(cx - radius * 1.2, cy);
                t.ctx.lineTo(cx + radius * 1.2, cy);
                t.ctx.moveTo(cx, cy - radius * 1.2);
                t.ctx.lineTo(cx, cy + radius * 1.2);
                t.ctx.stroke();

                // Animate angle
                t.angle += 0.02;
                const cosA = Math.cos(t.angle);
                const sinA = Math.sin(t.angle);
                const px = cx + cosA * radius;
                const py = cy - sinA * radius;

                // Cos projection (horizontal)
                t.ctx.strokeStyle = '#60a5fa';
                t.ctx.lineWidth = 3;
                t.ctx.beginPath();
                t.ctx.moveTo(cx, cy);
                t.ctx.lineTo(px, cy);
                t.ctx.stroke();

                // Sin projection (vertical)
                t.ctx.strokeStyle = '#4ade80';
                t.ctx.lineWidth = 3;
                t.ctx.beginPath();
                t.ctx.moveTo(px, cy);
                t.ctx.lineTo(px, py);
                t.ctx.stroke();

                // Radius
                t.ctx.strokeStyle = '#f97316';
                t.ctx.lineWidth = 2;
                t.ctx.beginPath();
                t.ctx.moveTo(cx, cy);
                t.ctx.lineTo(px, py);
                t.ctx.stroke();

                // Point
                t.ctx.fillStyle = '#f97316';
                t.ctx.beginPath();
                t.ctx.arc(px, py, 6, 0, Math.PI * 2);
                t.ctx.fill();

                // Angle arc
                t.ctx.strokeStyle = 'rgba(249, 115, 22, 0.5)';
                t.ctx.lineWidth = 2;
                t.ctx.beginPath();
                t.ctx.arc(cx, cy, radius * 0.2, 0, -t.angle, t.angle > 0);
                t.ctx.stroke();
            }

            // Probabilidad - Normal distribution histogram
            if (previews.prob) {
                const p = previews.prob;

                // Add samples periodically
                if (p.samples.length < 500) {
                    // Box-Muller transform for normal distribution
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    const sample = 0.5 + z * 0.15; // mu=0.5, sigma=0.15
                    if (sample >= 0 && sample <= 1) {
                        p.samples.push(sample);
                    }
                }

                p.ctx.fillStyle = '#000';
                p.ctx.fillRect(0, 0, p.w, p.h);

                // Draw histogram
                const bins = 30;
                const counts = new Array(bins).fill(0);
                p.samples.forEach(s => {
                    const bin = Math.min(bins - 1, Math.floor(s * bins));
                    counts[bin]++;
                });
                const maxCount = Math.max(...counts, 1);
                const barWidth = p.w / bins;

                counts.forEach((count, i) => {
                    const barHeight = (count / maxCount) * p.h * 0.8;
                    const gradient = p.ctx.createLinearGradient(0, p.h - barHeight, 0, p.h);
                    gradient.addColorStop(0, '#10b981');
                    gradient.addColorStop(1, '#064e3b');
                    p.ctx.fillStyle = gradient;
                    p.ctx.fillRect(i * barWidth + 1, p.h - barHeight, barWidth - 2, barHeight);
                });

                // Draw normal curve overlay
                p.ctx.strokeStyle = '#34d399';
                p.ctx.lineWidth = 2;
                p.ctx.beginPath();
                for (let x = 0; x < p.w; x++) {
                    const xNorm = x / p.w;
                    const z = (xNorm - 0.5) / 0.15;
                    const pdf = Math.exp(-0.5 * z * z) / (0.15 * Math.sqrt(2 * Math.PI));
                    const y = p.h - pdf * p.h * 0.15 * p.samples.length / 30;
                    if (x === 0) p.ctx.moveTo(x, y);
                    else p.ctx.lineTo(x, y);
                }
                p.ctx.stroke();
            }

            // Funciones - Sin wave with transformations
            if (previews.func) {
                const f = previews.func;
                f.ctx.fillStyle = '#000';
                f.ctx.fillRect(0, 0, f.w, f.h);

                const cx = f.w / 2;
                const cy = f.h / 2;

                // Draw axes
                f.ctx.strokeStyle = '#374151';
                f.ctx.lineWidth = 1;
                f.ctx.beginPath();
                f.ctx.moveTo(0, cy);
                f.ctx.lineTo(f.w, cy);
                f.ctx.moveTo(cx, 0);
                f.ctx.lineTo(cx, f.h);
                f.ctx.stroke();

                // Animate phase
                f.phase += 0.03;
                const amplitude = f.h * 0.3;
                const frequency = 3;

                // Draw sin wave
                f.ctx.strokeStyle = '#a855f7';
                f.ctx.lineWidth = 3;
                f.ctx.beginPath();
                for (let x = 0; x < f.w; x++) {
                    const xNorm = (x - cx) / (f.w / 4);
                    const y = cy - amplitude * Math.sin(frequency * xNorm + f.phase);
                    if (x === 0) f.ctx.moveTo(x, y);
                    else f.ctx.lineTo(x, y);
                }
                f.ctx.stroke();

                // Draw derivative (cos) with different color
                f.ctx.strokeStyle = '#22d3ee';
                f.ctx.lineWidth = 2;
                f.ctx.beginPath();
                for (let x = 0; x < f.w; x++) {
                    const xNorm = (x - cx) / (f.w / 4);
                    const y = cy - amplitude * 0.7 * Math.cos(frequency * xNorm + f.phase);
                    if (x === 0) f.ctx.moveTo(x, y);
                    else f.ctx.lineTo(x, y);
                }
                f.ctx.stroke();

                // Highlight a point on the curve
                const pointX = cx + Math.sin(f.phase * 0.5) * f.w * 0.3;
                const xNormPoint = (pointX - cx) / (f.w / 4);
                const pointY = cy - amplitude * Math.sin(frequency * xNormPoint + f.phase);

                f.ctx.fillStyle = '#a855f7';
                f.ctx.beginPath();
                f.ctx.arc(pointX, pointY, 6, 0, Math.PI * 2);
                f.ctx.fill();
            }

            // Geometría 3D - Rotating wireframe cube
            if (previews.geo3d) {
                const g = previews.geo3d;
                g.ctx.fillStyle = '#0a0a1a';
                g.ctx.fillRect(0, 0, g.w, g.h);

                const cx = g.w / 2;
                const cy = g.h / 2;
                const size = Math.min(g.w, g.h) * 0.25;

                g.angle += 0.015;
                const cosA = Math.cos(g.angle);
                const sinA = Math.sin(g.angle);
                const cosB = Math.cos(g.angle * 0.7);
                const sinB = Math.sin(g.angle * 0.7);

                // Cube vertices
                const vertices = [
                    [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                    [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
                ];

                // Rotate and project
                const projected = vertices.map(([x, y, z]) => {
                    // Rotate around Y
                    let rx = x * cosA - z * sinA;
                    let rz = x * sinA + z * cosA;
                    // Rotate around X
                    let ry = y * cosB - rz * sinB;
                    rz = y * sinB + rz * cosB;
                    // Project
                    const scale = 2 / (3 - rz);
                    return [cx + rx * size * scale, cy + ry * size * scale, rz];
                });

                // Edges
                const edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0],
                    [4, 5], [5, 6], [6, 7], [7, 4],
                    [0, 4], [1, 5], [2, 6], [3, 7]
                ];

                // Draw edges with depth coloring
                edges.forEach(([a, b]) => {
                    const avgZ = (projected[a][2] + projected[b][2]) / 2;
                    const alpha = 0.3 + (avgZ + 1) * 0.35;
                    g.ctx.strokeStyle = `rgba(234, 179, 8, ${alpha})`;
                    g.ctx.lineWidth = 2;
                    g.ctx.beginPath();
                    g.ctx.moveTo(projected[a][0], projected[a][1]);
                    g.ctx.lineTo(projected[b][0], projected[b][1]);
                    g.ctx.stroke();
                });

                // Draw vertices
                projected.forEach(([px, py, pz]) => {
                    const alpha = 0.5 + (pz + 1) * 0.25;
                    g.ctx.fillStyle = `rgba(234, 179, 8, ${alpha})`;
                    g.ctx.beginPath();
                    g.ctx.arc(px, py, 4, 0, Math.PI * 2);
                    g.ctx.fill();
                });
            }

            // Platonic Lab - Rotating icosahedron wireframe
            if (previews.platonic) {
                const p = previews.platonic;
                p.ctx.fillStyle = '#000';
                p.ctx.fillRect(0, 0, p.w, p.h);

                const cx = p.w / 2, cy = p.h / 2;
                const size = Math.min(p.w, p.h) * 0.3;
                p.angle += 0.012;
                const cosA = Math.cos(p.angle);
                const sinA = Math.sin(p.angle);
                const cosB = Math.cos(p.angle * 0.6);
                const sinB = Math.sin(p.angle * 0.6);

                const projected = p.vertices.map(([x, y, z]) => {
                    const rx = x * cosA - z * sinA;
                    const rz = x * sinA + z * cosA;
                    const ry = y * cosB - rz * sinB;
                    const rz2 = y * sinB + rz * cosB;
                    const s = 2.5 / (4 - rz2);
                    return [cx + rx * size * s, cy + ry * size * s, rz2];
                });

                p.edges.forEach(([a, b]) => {
                    const avgZ = (projected[a][2] + projected[b][2]) / 2;
                    const alpha = 0.2 + (avgZ + 2) * 0.2;
                    p.ctx.strokeStyle = `rgba(250, 204, 21, ${alpha})`;
                    p.ctx.lineWidth = 1.5;
                    p.ctx.beginPath();
                    p.ctx.moveTo(projected[a][0], projected[a][1]);
                    p.ctx.lineTo(projected[b][0], projected[b][1]);
                    p.ctx.stroke();
                });

                projected.forEach(([px, py, pz]) => {
                    const alpha = 0.4 + (pz + 2) * 0.15;
                    p.ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
                    p.ctx.beginPath();
                    p.ctx.arc(px, py, 3, 0, Math.PI * 2);
                    p.ctx.fill();
                });
            }

            // Chaos Lab - Lorenz attractor
            if (previews.chaos) {
                const c = previews.chaos;
                const sigma = 10, rho = 28, beta = 8 / 3;
                const dt = 0.005;

                for (let i = 0; i < 8; i++) {
                    const dx = sigma * (c.y - c.x);
                    const dy = c.x * (rho - c.z) - c.y;
                    const dz = c.x * c.y - beta * c.z;
                    c.x += dx * dt;
                    c.y += dy * dt;
                    c.z += dz * dt;
                    c.trail.push({ x: c.x, y: c.y, z: c.z });
                }
                if (c.trail.length > 800) c.trail.splice(0, 8);

                c.ctx.fillStyle = 'rgba(0,0,0,0.06)';
                c.ctx.fillRect(0, 0, c.w, c.h);

                const cx = c.w / 2, cy = c.h / 2;
                const scale = Math.min(c.w, c.h) / 55;
                const rotY = time * 0.15;

                if (c.trail.length > 1) {
                    for (let i = 1; i < c.trail.length; i++) {
                        const p = c.trail[i];
                        const prev = c.trail[i - 1];
                        const rx = p.x * Math.cos(rotY) - (p.z - 25) * Math.sin(rotY);
                        const prx = prev.x * Math.cos(rotY) - (prev.z - 25) * Math.sin(rotY);

                        const hue = 270 + (p.z / 50) * 60;
                        const alpha = i / c.trail.length;
                        c.ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha * 0.8})`;
                        c.ctx.lineWidth = 1.5;
                        c.ctx.beginPath();
                        c.ctx.moveTo(cx + prx * scale, cy - prev.y * scale + 30);
                        c.ctx.lineTo(cx + rx * scale, cy - p.y * scale + 30);
                        c.ctx.stroke();
                    }
                }
            }

            // Polytope XD - Rotating tesseract
            if (previews.polytope) {
                const p = previews.polytope;
                p.ctx.fillStyle = '#000';
                p.ctx.fillRect(0, 0, p.w, p.h);

                const cx = p.w / 2, cy = p.h / 2;
                const size = Math.min(p.w, p.h) * 0.22;
                p.angle += 0.01;

                // 4D rotation in XW and YZ planes
                const cosXW = Math.cos(p.angle);
                const sinXW = Math.sin(p.angle);
                const cosYZ = Math.cos(p.angle * 0.7);
                const sinYZ = Math.sin(p.angle * 0.7);

                const projected = p.vertices.map(([x, y, z, w]) => {
                    // Rotate in XW plane
                    const rx = x * cosXW - w * sinXW;
                    const rw = x * sinXW + w * cosXW;
                    // Rotate in YZ plane
                    const ry = y * cosYZ - z * sinYZ;
                    const rz = y * sinYZ + z * cosYZ;
                    // Perspective projection 4D→3D
                    const d4 = 3 / (3.5 - rw);
                    const x3 = rx * d4;
                    const y3 = ry * d4;
                    const z3 = rz * d4;
                    // 3D rotation for viewing angle
                    const cosV = Math.cos(0.4);
                    const sinV = Math.sin(0.4);
                    const ry2 = y3 * cosV - z3 * sinV;
                    const rz2 = y3 * sinV + z3 * cosV;
                    // 3D→2D perspective
                    const d3 = 2.5 / (4 - rz2);
                    return [cx + x3 * size * d3, cy + ry2 * size * d3, rz2, rw];
                });

                p.edges.forEach(([a, b]) => {
                    const avgW = (projected[a][3] + projected[b][3]) / 2;
                    const hue = 190 + avgW * 20;
                    const alpha = 0.3 + (avgW + 1.5) * 0.2;
                    p.ctx.strokeStyle = `hsla(${hue}, 70%, 55%, ${alpha})`;
                    p.ctx.lineWidth = 1.5;
                    p.ctx.beginPath();
                    p.ctx.moveTo(projected[a][0], projected[a][1]);
                    p.ctx.lineTo(projected[b][0], projected[b][1]);
                    p.ctx.stroke();
                });

                projected.forEach(([px, py, pz, pw]) => {
                    const hue = 190 + pw * 20;
                    const alpha = 0.4 + (pw + 1.5) * 0.2;
                    p.ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                    p.ctx.beginPath();
                    p.ctx.arc(px, py, 2.5, 0, Math.PI * 2);
                    p.ctx.fill();
                });
            }

            requestAnimationFrame(animate);
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        window.addEventListener('load', () => {
            initPreviews();
            animate();
        });

        window.addEventListener('resize', initPreviews);
    </script>
</body>
</html>
