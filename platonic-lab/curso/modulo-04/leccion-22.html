<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lección 22: Proyecciones — De 4D a Nuestra Pantalla | Matemáticas Visuales</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .glow-text { text-shadow: 0 0 20px rgba(168, 85, 247, 0.5); }
        .progress-bar { background: linear-gradient(90deg, #a855f7, #22d3ee); }
        .katex { color: inherit; font-size: 1.1em; }
    </style>
</head>
<body class="bg-black text-gray-100 min-h-screen">

    <!-- HEADER -->
    <header class="border-b border-gray-800 sticky top-0 z-50 bg-black/90 backdrop-blur">
        <div class="max-w-6xl mx-auto px-6 py-3 flex items-center justify-between">
            <nav class="text-xs text-gray-500">
                <a href="../../../../../_portal/index.html" class="hover:text-violet-400 transition">EigenLab</a>
                <span class="mx-1">/</span>
                <a href="../../../index.html" class="hover:text-violet-400 transition">Math Visual Lab</a>
                <span class="mx-1">/</span>
                <a href="../../index.html" class="hover:text-violet-400 transition">Platonic Lab</a>
                <span class="mx-1">/</span>
                <a href="../index.html" class="hover:text-violet-400 transition">Curso</a>
                <span class="mx-1">/</span>
                <span class="text-gray-400">Modulo 04</span>
            </nav>
            <nav class="flex space-x-3 text-sm">
                <a href="./leccion-21.html" class="px-3 py-1.5 rounded border border-gray-700 hover:border-violet-500 text-gray-400 hover:text-violet-300 transition">Anterior</a>
                <a href="./leccion-23.html" class="px-3 py-1.5 rounded bg-violet-600 hover:bg-violet-500 text-white transition">Siguiente</a>
            </nav>
        </div>
    </header>

    <div class="max-w-6xl mx-auto px-6 py-10 grid grid-cols-1 lg:grid-cols-4 gap-10">

        <!-- SIDEBAR -->
        <aside class="lg:col-span-1">
            <div class="border border-gray-800 rounded-lg p-5 sticky top-20">
                <h3 class="text-sm font-semibold text-violet-400 mb-1">Modulo 04</h3>
                <p class="text-xs text-gray-500 mb-4">Mas Alla de la 3D</p>
                <div class="mb-5">
                    <div class="flex justify-between text-xs text-gray-500 mb-1.5">
                        <span>Progreso</span>
                        <span>4/6</span>
                    </div>
                    <div class="w-full bg-gray-800 rounded-full h-1.5">
                        <div class="progress-bar h-1.5 rounded-full" style="width: 66.6%"></div>
                    </div>
                </div>
                <nav class="space-y-1 text-sm">
                    <a href="./leccion-19.html" class="block px-3 py-2 rounded text-gray-400 hover:text-gray-200 hover:bg-gray-900 transition">19. El Salto a la Cuarta Dimension</a>
                    <a href="./leccion-20.html" class="block px-3 py-2 rounded text-gray-400 hover:text-gray-200 hover:bg-gray-900 transition">20. Los Seis Politopos Regulares</a>
                    <a href="./leccion-21.html" class="block px-3 py-2 rounded text-gray-400 hover:text-gray-200 hover:bg-gray-900 transition">21. Euler-Poincare y Dualidad</a>
                    <a href="./leccion-22.html" class="block px-3 py-2 rounded bg-violet-600/20 border border-violet-500/30 text-violet-300 font-medium">22. Proyecciones: De 4D a Pantalla</a>
                    <a href="./leccion-23.html" class="block px-3 py-2 rounded text-gray-400 hover:text-gray-200 hover:bg-gray-900 transition">23. Rotaciones en 4D y el 24-celda</a>
                    <a href="./leccion-24.html" class="block px-3 py-2 rounded text-gray-400 hover:text-gray-200 hover:bg-gray-900 transition">24. Dimensiones Superiores y Sintesis</a>
                </nav>
            </div>
        </aside>

        <!-- MAIN CONTENT -->
        <main class="lg:col-span-3 space-y-10">

            <!-- TITLE BLOCK -->
            <section>
                <span class="text-cyan-400 text-sm font-medium">Leccion 22</span>
                <h2 class="text-3xl font-light mt-2 mb-4">
                    <span class="text-violet-400 font-medium glow-text">Proyecciones:</span> De 4D a Nuestra Pantalla
                </h2>
                <p class="text-gray-400 text-lg">Tecnicas matematicas para visualizar lo invisible. Cada proyeccion tiene una formula y preserva propiedades distintas.</p>
            </section>

            <!-- 1. EL PROBLEMA DE LA VISUALIZACION -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">1. El Problema de la Visualizacion</h3>
                <p class="text-gray-300 mb-4">
                    Los objetos en \(\mathbb{R}^4\) no caben en nuestro espacio tridimensional, y mucho menos en la pantalla bidimensional.
                    Para ver un politopo 4D necesitamos un <span class="text-white font-medium">pipeline de proyecciones</span>:
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5 text-center">
                    <p class="mono text-lg text-violet-300">
                        \(\mathbb{R}^4 \;\xrightarrow{\;\pi_1\;}\; \mathbb{R}^3 \;\xrightarrow{\;\pi_2\;}\; \mathbb{R}^2 \;\text{(pantalla)}\)
                    </p>
                </div>
                <p class="text-gray-300 mb-4">
                    Consideremos la analogia descendente. Un ser bidimensional que vive en un plano
                    no puede ver un cubo 3D directamente. Solo puede percibir:
                </p>
                <ul class="list-disc list-inside text-gray-300 space-y-2 mb-4 ml-2">
                    <li><span class="text-white font-medium">Sombras:</span> la proyeccion del cubo sobre su plano, un hexagono o un cuadrado segun el angulo.</li>
                    <li><span class="text-white font-medium">Secciones transversales:</span> la interseccion del cubo con su plano, que puede ser un cuadrado, un rectangulo, un triangulo o un hexagono.</li>
                </ul>
                <p class="text-gray-300 mb-4">
                    Nosotros estamos en la misma situacion con respecto a \(\mathbb{R}^4\).
                    La perdida de informacion es inevitable: una proyeccion de \(\mathbb{R}^n\) a \(\mathbb{R}^m\)
                    con \(m < n\) no puede ser inyectiva (por el teorema de la dimension). Distintas proyecciones
                    preservan distintas propiedades geometricas, y ninguna las preserva todas.
                </p>
                <p class="text-gray-300">
                    Estudiaremos cuatro herramientas fundamentales: la <span class="text-white font-medium">proyeccion ortogonal</span>,
                    la <span class="text-white font-medium">proyeccion perspectiva</span>, la <span class="text-white font-medium">proyeccion estereografica</span>,
                    las <span class="text-white font-medium">secciones transversales</span>, y los <span class="text-white font-medium">diagramas de Schlegel</span>.
                </p>
            </section>

            <!-- 2. PROYECCION ORTOGONAL -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">2. Proyeccion Ortogonal</h3>
                <p class="text-gray-300 mb-4">
                    La proyeccion mas simple: descartamos la coordenada \(w\).
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5">
                    <p class="text-sm text-gray-500 mb-2 mono">Definicion</p>
                    $$\pi_{\text{ort}} : \mathbb{R}^4 \to \mathbb{R}^3, \quad (x, y, z, w) \mapsto (x, y, z)$$
                </div>
                <p class="text-gray-300 mb-4">
                    Matricialmente, esto es la multiplicacion por la matriz \(3 \times 4\):
                </p>
                $$P_{\text{ort}} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$
                <p class="text-gray-300 mb-4 mt-4">
                    <span class="text-white font-medium">Ventaja:</span> preserva las distancias en el hiperplano de proyeccion. Si dos puntos tienen las mismas
                    coordenadas \((x,y,z)\), su distancia proyectada es exactamente su distancia real en esas tres coordenadas.
                    Formalmente, para puntos \(\mathbf{p}, \mathbf{q}\) con \(w_p = w_q\):
                </p>
                $$\|\pi_{\text{ort}}(\mathbf{p}) - \pi_{\text{ort}}(\mathbf{q})\| = \|\mathbf{p} - \mathbf{q}\|$$
                <p class="text-gray-300 mb-4 mt-4">
                    <span class="text-white font-medium">Desventaja:</span> toda informacion sobre la profundidad en \(w\) se pierde. Puntos con distinto \(w\)
                    pero iguales \((x,y,z)\) colapsan al mismo punto.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Ejemplo concreto: el teseracto.</span>
                    Los 16 vertices del teseracto son todas las combinaciones de \((\pm 1, \pm 1, \pm 1, \pm 1)\).
                    Bajo proyeccion ortogonal, los vertices se agrupan en 8 pares que se superponen:
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-4 overflow-x-auto">
                    <table class="text-sm text-gray-300 mono w-full">
                        <thead>
                            <tr class="border-b border-gray-700">
                                <th class="text-left py-2 px-3 text-violet-400">Vertice 4D</th>
                                <th class="text-left py-2 px-3 text-violet-400">Proyeccion 3D</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="border-b border-gray-800">
                                <td class="py-2 px-3">(1, 1, 1, <span class="text-cyan-400">+1</span>)</td>
                                <td class="py-2 px-3" rowspan="2">(1, 1, 1)</td>
                            </tr>
                            <tr class="border-b border-gray-800">
                                <td class="py-2 px-3">(1, 1, 1, <span class="text-cyan-400">-1</span>)</td>
                            </tr>
                            <tr class="border-b border-gray-800">
                                <td class="py-2 px-3">(1, 1, -1, <span class="text-cyan-400">+1</span>)</td>
                                <td class="py-2 px-3" rowspan="2">(1, 1, -1)</td>
                            </tr>
                            <tr class="border-b border-gray-800">
                                <td class="py-2 px-3">(1, 1, -1, <span class="text-cyan-400">-1</span>)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="text-xs text-gray-500 mt-3">Y asi para los 8 pares. 16 vertices 4D colapsan en 8 puntos 3D.</p>
                </div>
                <p class="text-gray-300">
                    El resultado visual es un "cubo dentro de un cubo" donde el cubo interior y el exterior
                    se superponen perfectamente, produciendo la clasica imagen de un cubo con todas las diagonales.
                </p>
            </section>

            <!-- 3. PROYECCION PERSPECTIVA -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">3. Proyeccion Perspectiva</h3>
                <p class="text-gray-300 mb-4">
                    La proyeccion perspectiva simula un "ojo" ubicado a distancia \(d\) del origen a lo largo del eje \(w\).
                    Objetos mas lejanos en \(w\) aparecen mas pequenos, exactamente como la perspectiva 3D habitual.
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5">
                    <p class="text-sm text-gray-500 mb-2 mono">Definicion</p>
                    $$\pi_{\text{persp}} : \mathbb{R}^4 \to \mathbb{R}^3, \quad (x, y, z, w) \mapsto \left(\frac{x \cdot d}{w + d},\; \frac{y \cdot d}{w + d},\; \frac{z \cdot d}{w + d}\right)$$
                </div>
                <p class="text-gray-300 mb-4">
                    donde \(d > 0\) es la distancia del punto de vista al origen, medida sobre el eje \(w\).
                    El observador esta en \((0, 0, 0, -d)\) y mira hacia \(w\) creciente.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Derivacion por triangulos semejantes.</span>
                    Coloquemos el observador en \(O = (0,0,0,-d)\) y el plano de proyeccion en \(w = 0\).
                    Un punto \(P = (x,y,z,w)\) se conecta con \(O\) mediante la recta:
                </p>
                $$\ell(t) = O + t(P - O) = (tx,\; ty,\; tz,\; -d + t(w+d))$$
                <p class="text-gray-300 mb-4 mt-4">
                    Buscamos el valor de \(t\) donde \(\ell\) interseca el hiperplano \(w=0\):
                </p>
                $$-d + t(w + d) = 0 \;\;\Longrightarrow\;\; t = \frac{d}{w + d}$$
                <p class="text-gray-300 mb-4 mt-4">
                    Sustituyendo en las tres primeras coordenadas:
                </p>
                $$\pi_{\text{persp}}(P) = \left(\frac{xd}{w+d},\; \frac{yd}{w+d},\; \frac{zd}{w+d}\right)$$
                <p class="text-gray-300 mb-4 mt-4">
                    El factor \(\frac{d}{w+d}\) es el <span class="text-white font-medium">factor de escala perspectivo</span>.
                    Cuando \(w\) es grande (punto lejano), el denominador crece y el punto proyectado se acerca al origen:
                    aparece mas pequeno. Cuando \(w\) es negativo y cercano a \(-d\), el punto "explota" hacia el infinito.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Ejemplo: el teseracto con \(d = 3\).</span>
                    Los vertices con \(w = +1\) tienen factor de escala \(\frac{3}{1+3} = \frac{3}{4}\),
                    y los vertices con \(w = -1\) tienen factor \(\frac{3}{-1+3} = \frac{3}{2}\).
                    Asi, el "cubo interior" (\(w=+1\)) aparece con lado \(\frac{3}{2}\) y el "cubo exterior"
                    (\(w=-1\)) con lado \(3\). El resultado es la imagen iconica del teseracto:
                    un cubo pequeno centrado dentro de uno grande, conectados por aristas.
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-4">
                    <p class="text-sm text-gray-500 mb-2 mono">Limite: perspectiva tiende a ortogonal</p>
                    <p class="text-gray-300">Cuando \(d \to \infty\), el factor de escala se uniformiza:</p>
                    $$\lim_{d \to \infty} \frac{d}{w+d} = \lim_{d \to \infty} \frac{1}{w/d + 1} = 1$$
                    <p class="text-gray-300 mt-3">y la proyeccion perspectiva se reduce a la ortogonal: \((x,y,z,w) \mapsto (x,y,z)\).</p>
                </div>
            </section>

            <!-- 4. PROYECCION ESTEREOGRAFICA -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">4. Proyeccion Estereografica</h3>
                <p class="text-gray-300 mb-4">
                    La proyeccion estereografica opera sobre la 3-esfera \(S^3 \subset \mathbb{R}^4\), proyectando
                    desde el "polo norte" \(N = (0,0,0,1)\) hacia el hiperplano ecuatorial \(\{x_4 = 0\} \cong \mathbb{R}^3\).
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5">
                    <p class="text-sm text-gray-500 mb-2 mono">Definicion</p>
                    $$\sigma : S^3 \setminus \{N\} \to \mathbb{R}^3, \quad (x_1, x_2, x_3, x_4) \mapsto \frac{(x_1,\, x_2,\, x_3)}{1 - x_4}$$
                </div>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Derivacion.</span>
                    El punto \(P = (x_1, x_2, x_3, x_4) \in S^3\) y el polo \(N = (0,0,0,1)\) determinan una recta:
                </p>
                $$\ell(t) = N + t(P - N) = (tx_1,\; tx_2,\; tx_3,\; 1 + t(x_4 - 1))$$
                <p class="text-gray-300 mb-4 mt-4">
                    Intersecamos con \(x_4 = 0\):
                </p>
                $$1 + t(x_4 - 1) = 0 \;\;\Longrightarrow\;\; t = \frac{1}{1 - x_4}$$
                <p class="text-gray-300 mb-4 mt-4">
                    Sustituyendo en las tres primeras coordenadas:
                </p>
                $$\sigma(P) = \left(\frac{x_1}{1-x_4},\; \frac{x_2}{1-x_4},\; \frac{x_3}{1-x_4}\right)$$
                <p class="text-gray-300 mb-4 mt-4">
                    <span class="text-white font-medium">Propiedad fundamental: conformalidad.</span>
                    La proyeccion estereografica es <span class="text-white font-medium">conforme</span>: preserva angulos.
                    Para verificarlo, calculamos la diferencial. Si \(P \in S^3\) con \(x_1^2 + x_2^2 + x_3^2 + x_4^2 = 1\),
                    la jacobiana de \(\sigma\) en las coordenadas tangentes al punto es:
                </p>
                $$D\sigma_P = \frac{1}{1 - x_4}\left(I_3 + \frac{1}{1 - x_4}\,\mathbf{x}\,\mathbf{e}_4^T\right)$$
                <p class="text-gray-300 mb-4 mt-4">
                    donde \(\mathbf{x} = (x_1, x_2, x_3)^T\). Restringida al espacio tangente \(T_P S^3\),
                    esta diferencial es proporcional a una isometria con factor de escala \(\frac{1}{1-x_4}\).
                    Esto significa que el angulo entre dos curvas en \(S^3\) se preserva exactamente en \(\mathbb{R}^3\).
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Consecuencia geometrica:</span>
                    los circulos maximos en \(S^3\) se transforman en circulos (o rectas) en \(\mathbb{R}^3\).
                    Esto produce las imagenes mas esteticas de los politopos 4D: aristas curvas que fluyen
                    suavemente, revelando la simetria interna de la estructura.
                </p>
                <p class="text-gray-300">
                    Para politopos que no viven en \(S^3\), primero proyectamos radialmente cada vertice
                    sobre \(S^3\) (normalizando a norma 1) y luego aplicamos \(\sigma\). Alternativamente,
                    inscribimos el politopo en \(S^3\) escalandolo adecuadamente.
                </p>
            </section>

            <!-- 5. SECCIONES TRANSVERSALES -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">5. Secciones Transversales</h3>
                <p class="text-gray-300 mb-4">
                    En lugar de proyectar, podemos <span class="text-white font-medium">cortar</span> el objeto 4D con un hiperplano
                    \(w = t\) y examinar la seccion resultante, que es un poliedro 3D que podemos ver completamente.
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5">
                    <p class="text-sm text-gray-500 mb-2 mono">Definicion</p>
                    <p class="text-gray-300">Sea \(\mathcal{P} \subset \mathbb{R}^4\) un politopo. La seccion transversal a altura \(t\) es:</p>
                    $$\mathcal{P}_t = \mathcal{P} \cap \{(x,y,z,w) : w = t\}$$
                </div>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Analogia en 3D.</span>
                    Cortemos un cubo \(\{(x,y,z) : \max(|x|,|y|,|z|) \leq 1\}\) con un plano perpendicular
                    a la diagonal principal \((1,1,1)\). Cuando el plano avanza desde un vertice:
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5 text-center">
                    <p class="mono text-gray-300">
                        punto <span class="text-violet-400 mx-2">--></span>
                        triangulo <span class="text-violet-400 mx-2">--></span>
                        hexagono <span class="text-violet-400 mx-2">--></span>
                        triangulo <span class="text-violet-400 mx-2">--></span>
                        punto
                    </p>
                </div>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">El teseracto cortado diagonalmente.</span>
                    Consideremos el teseracto \(\{(x,y,z,w) : \max(|x|,|y|,|z|,|w|) \leq 1\}\) cortado por el hiperplano
                    perpendicular a la diagonal principal \((1,1,1,1)\). Parametrizamos la posicion del corte
                    con \(t = x+y+z+w\). Cuando \(t\) avanza desde \(-4\) (vertice \((-1,-1,-1,-1)\)) hasta \(+4\):
                </p>
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-5 mb-5 text-center">
                    <p class="mono text-gray-300">
                        punto <span class="text-violet-400 mx-2">--></span>
                        tetraedro <span class="text-violet-400 mx-2">--></span>
                        octaedro <span class="text-violet-400 mx-2">--></span>
                        tetraedro <span class="text-violet-400 mx-2">--></span>
                        punto
                    </p>
                </div>
                <p class="text-gray-300 mb-4">
                    Esto es profundamente bello: la seccion maxima del teseracto (el corte por la mitad)
                    es un <span class="text-white font-medium">octaedro regular</span>, un solido platonico 3D emergiendo de la geometria 4D.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Cortes simples con \(w = t\).</span>
                    Para el corte mas sencillo, intersecamos con \(w = t\) directamente:
                </p>
                $$\mathcal{T}_t = \{(x,y,z) : \max(|x|, |y|, |z|) \leq 1\} \quad \text{para } |t| \leq 1$$
                <p class="text-gray-300 mt-4">
                    Cada seccion es simplemente un cubo unitario. Esto tiene sentido:
                    el teseracto es el producto \([-1,1]^3 \times [-1,1]\), y fijar \(w = t\) deja el factor cubico intacto.
                    La seccion solo existe cuando \(|t| \leq 1\); fuera de ese rango, la seccion es vacia.
                </p>
            </section>

            <!-- 6. DIAGRAMAS DE SCHLEGEL -->
            <section>
                <h3 class="text-xl font-semibold text-violet-400 mb-4">6. Diagramas de Schlegel</h3>
                <p class="text-gray-300 mb-4">
                    El diagrama de Schlegel es una proyeccion perspectiva desde un punto ligeramente exterior
                    al centro de una celda del politopo. El resultado es una representacion donde
                    <span class="text-white font-medium">una celda grande contiene todas las demas</span>.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Analogia 3D: el cubo.</span>
                    Si miramos un cubo transparente directamente a traves de una cara, vemos:
                    un cuadrado grande (la cara frontal) que contiene un cuadrado mas pequeno (la cara trasera),
                    conectados por cuatro trapezoides (las caras laterales). En total, 6 caras representadas en 2D.
                </p>
                <p class="text-gray-300 mb-4">
                    <span class="text-white font-medium">Construccion matematica.</span>
                    Sea \(\mathcal{F}\) una celda del politopo \(\mathcal{P}\). Elegimos un punto \(O\) sobre la recta
                    que une el centro de \(\mathcal{P}\) con el centro de \(\mathcal{F}\), pero ligeramente
                    fuera de \(\mathcal{P}\). Proyectamos todos los vertices de \(\mathcal{P}\) desde \(O\)
                    sobre el hiperplano que contiene \(\mathcal{F}\):
                </p>
                $$\pi_{\text{Schlegel}}(\mathbf{v}) = O + \frac{t^*}{1}\,({\mathbf{v} - O}), \quad \text{donde } t^* \text{ es tal que } \pi(\mathbf{v}) \in \text{aff}(\mathcal{F})$$
                <p class="text-gray-300 mb-4 mt-4">
                    <span class="text-white font-medium">Teseracto: diagrama de Schlegel.</span>
                    El teseracto tiene 8 celdas cubicas. Su diagrama de Schlegel muestra un cubo grande
                    (la celda a traves de la cual proyectamos) que contiene 7 cubos distorsionados:
                </p>
                <ul class="list-disc list-inside text-gray-300 space-y-2 mb-4 ml-2">
                    <li>1 cubo pequeno en el centro (la celda opuesta)</li>
                    <li>6 cubos frustum que conectan las caras del cubo grande con las del cubo pequeno</li>
                </ul>
                <p class="text-gray-300">
                    Los 7 cubos interiores llenan exactamente el volumen del cubo grande sin solaparse,
                    formando una <span class="text-white font-medium">particion</span> del cubo exterior.
                    Los diagramas de Schlegel son especialmente utiles para estudiar la estructura combinatoria
                    (incidencia de vertices, aristas, caras, celdas) porque todas las relaciones de adyacencia
                    son visibles en una sola imagen.
                </p>
            </section>

            <!-- EXERCISES -->
            <section class="border-t border-gray-800 pt-8">
                <h3 class="text-xl font-semibold text-cyan-400 mb-6">Ejercicios</h3>

                <div class="space-y-6">
                    <div class="bg-gray-900/50 border border-gray-800 rounded-lg p-5">
                        <p class="text-sm text-cyan-400 mono mb-2">Ejercicio 1</p>
                        <p class="text-gray-300">
                            Aplica la proyeccion perspectiva con \(d = 3\) al vertice \((1, 1, 1, 1)\) del teseracto
                            y al vertice \((1, 1, 1, -1)\). Calcula las coordenadas proyectadas de cada uno.
                            Cual aparece mas cerca del origen (y por tanto mas "pequeno" en la proyeccion)?
                            Explica geometricamente por que.
                        </p>
                    </div>

                    <div class="bg-gray-900/50 border border-gray-800 rounded-lg p-5">
                        <p class="text-sm text-cyan-400 mono mb-2">Ejercicio 2</p>
                        <p class="text-gray-300">
                            Verifica que la proyeccion estereografica es conforme. Para ello, calcula la jacobiana
                            de \(\sigma(x_1, x_2, x_3, x_4) = \frac{(x_1, x_2, x_3)}{1 - x_4}\) y muestra que,
                            restringida al espacio tangente de \(S^3\), es proporcional a una isometria
                            (es decir, \(D\sigma^T D\sigma = \lambda^2 \, I\) para algun escalar \(\lambda\)).
                        </p>
                    </div>

                    <div class="bg-gray-900/50 border border-gray-800 rounded-lg p-5">
                        <p class="text-sm text-cyan-400 mono mb-2">Ejercicio 3</p>
                        <p class="text-gray-300">
                            Cuando cortamos el teseracto \(\{(x,y,z,w) : \max(|x|,|y|,|z|,|w|) \leq 1\}\) con el
                            hiperplano \(w = 0\), que poliedro obtenemos? Describe sus vertices y aristas.
                            Que ocurre con \(w = 0.5\)? Y con \(w = 1\)?
                        </p>
                    </div>

                    <div class="bg-gray-900/50 border border-gray-800 rounded-lg p-5">
                        <p class="text-sm text-cyan-400 mono mb-2">Ejercicio 4</p>
                        <p class="text-gray-300">
                            Dibuja el diagrama de Schlegel del teseracto: un cubo grande conteniendo 7 cubos mas
                            pequenos. Identifica las 8 celdas cubicas. Verifica que cada arista del teseracto
                            aparece exactamente una vez en el diagrama.
                        </p>
                    </div>

                    <div class="bg-gray-900/50 border border-gray-800 rounded-lg p-5">
                        <p class="text-sm text-cyan-400 mono mb-2">Ejercicio 5</p>
                        <p class="text-gray-300">
                            La 5-celda (simplejos 4D) tiene 5 vertices, 10 aristas, 10 caras triangulares y 5 celdas
                            tetraedricas. Si cortamos la 5-celda con un hiperplano que pasa por su centro
                            (equidistante de todos los vertices), que poliedro obtenemos como seccion transversal?
                            Pista: piensa en la analogia con cortar un tetraedro por su centro.
                        </p>
                    </div>
                </div>
            </section>

            <!-- LAB -->
            <section class="border-t border-gray-800 pt-8">
                <h3 class="text-xl font-semibold text-cyan-400 mb-2">LAB: Explorador de Proyecciones</h3>
                <p class="text-gray-400 mb-5">Visualiza el teseracto y la 5-celda bajo distintos tipos de proyeccion. Arrastra para rotar en 3D. El politopo rota automaticamente en el plano XW.</p>

                <!-- Controls -->
                <div class="bg-gray-900 border border-gray-800 rounded-lg p-4 mb-4 space-y-4">
                    <div class="flex flex-wrap gap-3 items-center">
                        <span class="text-xs text-gray-500 mono w-20">Politopo:</span>
                        <button id="btn-tesseract" class="px-3 py-1.5 text-xs mono rounded bg-violet-600 text-white transition" onclick="setPolytope('tesseract')">Teseracto</button>
                        <button id="btn-5cell" class="px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition" onclick="setPolytope('cell5')">5-celda</button>
                    </div>
                    <div class="flex flex-wrap gap-3 items-center">
                        <span class="text-xs text-gray-500 mono w-20">Proyeccion:</span>
                        <button id="btn-ortho" class="px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition" onclick="setProjection('orthogonal')">Ortogonal</button>
                        <button id="btn-persp" class="px-3 py-1.5 text-xs mono rounded bg-violet-600 text-white transition" onclick="setProjection('perspective')">Perspectiva</button>
                        <button id="btn-stereo" class="px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition" onclick="setProjection('stereographic')">Estereografica</button>
                    </div>
                    <div class="flex flex-wrap gap-3 items-center">
                        <label class="text-xs text-gray-500 mono w-20">d = <span id="d-value" class="text-violet-300">3.0</span></label>
                        <input id="slider-d" type="range" min="1.5" max="20" step="0.1" value="3" class="flex-1 accent-violet-500" oninput="updateD(this.value)">
                    </div>
                    <div class="flex flex-wrap gap-3 items-center">
                        <label class="text-xs text-gray-500 mono w-20">Corte w = <span id="w-value" class="text-cyan-300">OFF</span></label>
                        <input id="slider-w" type="range" min="-1.5" max="1.5" step="0.02" value="2" class="flex-1 accent-cyan-500" oninput="updateW(this.value)">
                        <button id="btn-cross" class="px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition" onclick="toggleCrossSection()">Activar corte</button>
                    </div>
                </div>

                <!-- Three.js Canvas -->
                <div id="lab-container" class="border border-gray-800 rounded-lg overflow-hidden" style="height: 520px; background: #050505;"></div>
            </section>

            <!-- BOTTOM NAV -->
            <nav class="border-t border-gray-800 pt-8 flex justify-between items-center">
                <a href="./leccion-21.html" class="px-5 py-2.5 rounded border border-gray-700 hover:border-violet-500 text-gray-400 hover:text-violet-300 transition text-sm">
                    &larr; Euler-Poincare
                </a>
                <a href="./leccion-23.html" class="px-5 py-2.5 rounded bg-violet-600 hover:bg-violet-500 text-white transition text-sm">
                    Siguiente: Rotaciones en 4D &rarr;
                </a>
            </nav>
        </main>
    </div>

    <!-- FOOTER -->
    <footer class="border-t border-gray-900 py-6 mt-12">
        <div class="max-w-6xl mx-auto px-6">
            <nav class="text-xs text-gray-600 text-center mb-2">
                <a href="../../../../../_portal/index.html" class="hover:text-violet-400 transition">EigenLab</a>
                <span class="mx-1">/</span>
                <a href="../../../index.html" class="hover:text-violet-400 transition">Math Visual Lab</a>
                <span class="mx-1">/</span>
                <a href="../../index.html" class="hover:text-violet-400 transition">Platonic Lab</a>
                <span class="mx-1">/</span>
                <a href="../index.html" class="hover:text-violet-400 transition">Curso</a>
            </nav>
            <p class="text-center text-gray-700 text-sm mono">Matematicas Visuales -- De Platon a 4D</p>
        </div>
    </footer>

    <!-- THREE.JS -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // === POLYTOPE DATA ===

        function tesseractData() {
            const verts = [];
            for (let i = 0; i < 16; i++) {
                verts.push([
                    (i & 1) ? 1 : -1,
                    (i & 2) ? 1 : -1,
                    (i & 4) ? 1 : -1,
                    (i & 8) ? 1 : -1
                ]);
            }
            const edges = [];
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    let diff = 0;
                    for (let k = 0; k < 4; k++) {
                        if (verts[i][k] !== verts[j][k]) diff++;
                    }
                    if (diff === 1) edges.push([i, j]);
                }
            }
            return { vertices: verts, edges: edges };
        }

        function cell5Data() {
            // 5-cell: 5 vertices of the regular 4-simplex
            const a = 1.0;
            const verts = [
                [ a,  a,  a, -1/Math.sqrt(5)],
                [ a, -a, -a, -1/Math.sqrt(5)],
                [-a,  a, -a, -1/Math.sqrt(5)],
                [-a, -a,  a, -1/Math.sqrt(5)],
                [ 0,  0,  0, Math.sqrt(5) - 1/Math.sqrt(5)]
            ];
            // Normalize to unit sphere and scale
            const scale = 1.8;
            for (let i = 0; i < verts.length; i++) {
                const len = Math.sqrt(verts[i].reduce((s, v) => s + v*v, 0));
                for (let k = 0; k < 4; k++) verts[i][k] = verts[i][k] / len * scale;
            }
            // All 10 edges (complete graph K5 minus nothing -- simplex has all edges)
            const edges = [];
            for (let i = 0; i < 5; i++) {
                for (let j = i + 1; j < 5; j++) {
                    edges.push([i, j]);
                }
            }
            return { vertices: verts, edges: edges };
        }

        // === STATE ===
        let currentPolytope = 'tesseract';
        let currentProjection = 'perspective';
        let paramD = 3.0;
        let crossSectionEnabled = false;
        let crossSectionW = 0.0;
        let angleXW = 0;
        let polytopeData = tesseractData();

        // Mouse rotation state
        let mouseRotX = 0.3;
        let mouseRotY = 0.5;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        // === THREE.JS SETUP ===
        const container = document.getElementById('lab-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
        camera.position.set(0, 0, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        container.appendChild(renderer.domElement);

        // Groups
        const rootGroup = new THREE.Group();
        scene.add(rootGroup);

        // Materials
        const vertexMat = new THREE.MeshBasicMaterial({ color: 0xa855f7 });
        const edgeMat = new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 1 });
        const crossVertexMat = new THREE.MeshBasicMaterial({ color: 0x22d3ee });
        const crossEdgeMat = new THREE.LineBasicMaterial({ color: 0x06b6d4, linewidth: 2 });
        const dimEdgeMat = new THREE.LineBasicMaterial({ color: 0x333344, linewidth: 1 });

        // Vertex sphere geometry (reused)
        const sphereGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const crossSphereGeo = new THREE.SphereGeometry(0.08, 8, 8);

        // === 4D ROTATION ===
        function rotateXW(v, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                v[0] * c - v[3] * s,
                v[1],
                v[2],
                v[0] * s + v[3] * c
            ];
        }

        // === PROJECTIONS ===
        function projectOrthogonal(v) {
            return new THREE.Vector3(v[0], v[1], v[2]);
        }

        function projectPerspective(v, d) {
            const denom = v[3] + d;
            if (Math.abs(denom) < 0.001) return new THREE.Vector3(v[0] * 1000, v[1] * 1000, v[2] * 1000);
            const scale = d / denom;
            return new THREE.Vector3(v[0] * scale, v[1] * scale, v[2] * scale);
        }

        function projectStereographic(v) {
            // Normalize to S3 first
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2] + v[3]*v[3]);
            const nx = v[0] / len, ny = v[1] / len, nz = v[2] / len, nw = v[3] / len;
            const denom = 1 - nw;
            if (Math.abs(denom) < 0.001) return new THREE.Vector3(nx * 1000, ny * 1000, nz * 1000);
            const s = 1.5 / denom; // scale for better visualization
            return new THREE.Vector3(nx * s, ny * s, nz * s);
        }

        function project4Dto3D(v) {
            switch (currentProjection) {
                case 'orthogonal': return projectOrthogonal(v);
                case 'perspective': return projectPerspective(v, paramD);
                case 'stereographic': return projectStereographic(v);
                default: return projectPerspective(v, paramD);
            }
        }

        // Color by w-depth
        function wColor(w) {
            // Map w from [-2, 2] to hue
            const t = (w + 2) / 4; // 0..1
            const r = Math.floor(120 + 135 * (1 - t));
            const g = Math.floor(80 + 100 * t);
            const b = Math.floor(200 + 55 * t);
            return new THREE.Color(`rgb(${Math.min(r,255)}, ${Math.min(g,255)}, ${Math.min(b,255)})`);
        }

        // === BUILD SCENE ===
        function rebuildScene() {
            // Clear
            while (rootGroup.children.length > 0) {
                const child = rootGroup.children[0];
                rootGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            const data = polytopeData;
            const rotated = data.vertices.map(v => rotateXW(v, angleXW));
            const projected = rotated.map(v => project4Dto3D(v));

            const crossTolerance = 0.3;

            // Determine which vertices/edges are near cross section
            function nearCross(v) {
                if (!crossSectionEnabled) return false;
                return Math.abs(v[3] - crossSectionW) < crossTolerance;
            }

            // Draw edges
            for (const [i, j] of data.edges) {
                const p1 = projected[i];
                const p2 = projected[j];
                const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);

                let mat;
                if (crossSectionEnabled) {
                    if (nearCross(rotated[i]) && nearCross(rotated[j])) {
                        mat = crossEdgeMat;
                    } else {
                        mat = dimEdgeMat;
                    }
                } else {
                    // Color by average w
                    const avgW = (rotated[i][3] + rotated[j][3]) / 2;
                    mat = new THREE.LineBasicMaterial({ color: wColor(avgW) });
                }

                const line = new THREE.Line(geo, mat);
                rootGroup.add(line);
            }

            // Draw vertices
            for (let i = 0; i < projected.length; i++) {
                const p = projected[i];
                let mesh;
                if (crossSectionEnabled && nearCross(rotated[i])) {
                    mesh = new THREE.Mesh(crossSphereGeo, crossVertexMat);
                } else if (crossSectionEnabled) {
                    // dim vertex
                    const dimMat = new THREE.MeshBasicMaterial({ color: 0x222233 });
                    mesh = new THREE.Mesh(sphereGeo, dimMat);
                } else {
                    const col = wColor(rotated[i][3]);
                    const mat = new THREE.MeshBasicMaterial({ color: col });
                    mesh = new THREE.Mesh(sphereGeo, mat);
                }
                mesh.position.copy(p);
                rootGroup.add(mesh);
            }

            // If cross section enabled, draw cross-section edges more prominently
            if (crossSectionEnabled) {
                // Also interpolate edges that cross the w=t plane
                for (const [i, j] of data.edges) {
                    const wi = rotated[i][3];
                    const wj = rotated[j][3];
                    // Check if the edge crosses the cross-section plane
                    if ((wi - crossSectionW) * (wj - crossSectionW) < 0) {
                        // Interpolate to find the crossing point
                        const t = (crossSectionW - wi) / (wj - wi);
                        const crossPt = [
                            rotated[i][0] + t * (rotated[j][0] - rotated[i][0]),
                            rotated[i][1] + t * (rotated[j][1] - rotated[i][1]),
                            rotated[i][2] + t * (rotated[j][2] - rotated[i][2]),
                            crossSectionW
                        ];
                        const projCross = project4Dto3D(crossPt);
                        const crossMesh = new THREE.Mesh(crossSphereGeo, crossVertexMat);
                        crossMesh.position.copy(projCross);
                        rootGroup.add(crossMesh);
                    }
                }
            }
        }

        // === ANIMATION LOOP ===
        let lastTime = performance.now();

        function animate(time) {
            requestAnimationFrame(animate);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            angleXW += dt * 0.4;

            rootGroup.rotation.x = mouseRotX;
            rootGroup.rotation.y = mouseRotY;

            rebuildScene();
            renderer.render(scene, camera);
        }

        requestAnimationFrame(animate);

        // === MOUSE INTERACTION ===
        renderer.domElement.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMouse.x = e.clientX;
            lastMouse.y = e.clientY;
        });
        renderer.domElement.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            mouseRotY += dx * 0.005;
            mouseRotX += dy * 0.005;
            lastMouse.x = e.clientX;
            lastMouse.y = e.clientY;
        });
        renderer.domElement.addEventListener('mouseup', function() { isDragging = false; });
        renderer.domElement.addEventListener('mouseleave', function() { isDragging = false; });

        // Touch support
        renderer.domElement.addEventListener('touchstart', function(e) {
            isDragging = true;
            lastMouse.x = e.touches[0].clientX;
            lastMouse.y = e.touches[0].clientY;
        }, { passive: true });
        renderer.domElement.addEventListener('touchmove', function(e) {
            if (!isDragging) return;
            const dx = e.touches[0].clientX - lastMouse.x;
            const dy = e.touches[0].clientY - lastMouse.y;
            mouseRotY += dx * 0.005;
            mouseRotX += dy * 0.005;
            lastMouse.x = e.touches[0].clientX;
            lastMouse.y = e.touches[0].clientY;
        }, { passive: true });
        renderer.domElement.addEventListener('touchend', function() { isDragging = false; });

        // Resize
        window.addEventListener('resize', function() {
            const w = container.clientWidth;
            const h = container.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });

        // === UI CONTROLS ===

        window.setPolytope = function(type) {
            currentPolytope = type;
            polytopeData = (type === 'tesseract') ? tesseractData() : cell5Data();
            document.getElementById('btn-tesseract').className = (type === 'tesseract')
                ? 'px-3 py-1.5 text-xs mono rounded bg-violet-600 text-white transition'
                : 'px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition';
            document.getElementById('btn-5cell').className = (type === 'cell5')
                ? 'px-3 py-1.5 text-xs mono rounded bg-violet-600 text-white transition'
                : 'px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition';
        };

        window.setProjection = function(type) {
            currentProjection = type;
            const btns = { 'orthogonal': 'btn-ortho', 'perspective': 'btn-persp', 'stereographic': 'btn-stereo' };
            for (const [key, id] of Object.entries(btns)) {
                document.getElementById(id).className = (key === type)
                    ? 'px-3 py-1.5 text-xs mono rounded bg-violet-600 text-white transition'
                    : 'px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition';
            }
            // Enable/disable d slider
            document.getElementById('slider-d').disabled = (type !== 'perspective');
            document.getElementById('slider-d').style.opacity = (type === 'perspective') ? '1' : '0.3';
        };

        window.updateD = function(val) {
            paramD = parseFloat(val);
            document.getElementById('d-value').textContent = paramD.toFixed(1);
        };

        window.updateW = function(val) {
            if (!crossSectionEnabled) return;
            crossSectionW = parseFloat(val);
            document.getElementById('w-value').textContent = crossSectionW.toFixed(2);
        };

        window.toggleCrossSection = function() {
            crossSectionEnabled = !crossSectionEnabled;
            const btn = document.getElementById('btn-cross');
            if (crossSectionEnabled) {
                btn.textContent = 'Desactivar corte';
                btn.className = 'px-3 py-1.5 text-xs mono rounded bg-cyan-600 text-white transition';
                crossSectionW = parseFloat(document.getElementById('slider-w').value);
                if (crossSectionW > 1.5) crossSectionW = 0;
                document.getElementById('slider-w').value = crossSectionW;
                document.getElementById('w-value').textContent = crossSectionW.toFixed(2);
            } else {
                btn.textContent = 'Activar corte';
                btn.className = 'px-3 py-1.5 text-xs mono rounded bg-gray-700 text-gray-300 hover:bg-gray-600 transition';
                document.getElementById('w-value').textContent = 'OFF';
            }
        };

    })();
    </script>

</body>
</html>
